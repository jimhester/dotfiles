#!/bin/bash
set -euo pipefail

# work - Start Claude Code session(s) for GitHub issue(s)
#
# By default, spawns each issue in a new terminal tab:
#   - macOS: Uses iTerm2
#   - WSL: Uses Windows Terminal
# Use --here to run in the current terminal instead.
#
# Usage: ./work <issue> [issue2 ...]      # Each in new tab (default)
#        ./work --here <issue>            # Run in current terminal
#        ./work "feature description"    # New feature branch

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
WORKTREE_BASE="${WORKTREE_BASE:-${HOME}/.worktrees}"
MAIN_BRANCH="${MAIN_BRANCH:-main}"
SPAWN_DELAY="${SPAWN_DELAY:-0.5}"
DB_PATH="${WORKTREE_BASE}/work-sessions.db"

usage() {
    cat <<EOF
Usage: $(basename "$0") <issue> [issue2 ...]
       $(basename "$0") --here <issue-url-or-number> [description]
       $(basename "$0") "description of new feature"

By default, spawns each issue in a new terminal tab (macOS iTerm2 or WSL Windows Terminal).

Examples:
  $(basename "$0") 97 98 99                    # Spawn 3 issues in new tabs
  $(basename "$0") https://github.com/owner/repo/issues/42
  $(basename "$0") --here 42 "fix memory leak"  # Run in current terminal
  $(basename "$0") "add dark mode support"      # New feature branch

Worker Management:
  $(basename "$0") --status                    # Show all active workers
  $(basename "$0") --events [issue]            # Show recent events (optionally filtered)
  $(basename "$0") --logs <issue>              # Stream worker output
  $(basename "$0") --stop <issue>              # Signal worker to stop
  $(basename "$0") --send <issue> <message>    # Send message to worker
  $(basename "$0") --messages [issue]          # View and mark messages as read
  $(basename "$0") --messages [issue] --peek   # View without marking as read
  $(basename "$0") --stage <stage> [issue]     # Set worker stage (for progress tracking)

  Issue arguments support:
    - Issue number: 42 (defaults to current repo)
    - PR number: 47 (searches both issue_number and pr_number)
    - Explicit repo: myrepo:42 (for cross-repo lookups)

Options:
  --here       Run in current terminal instead of spawning new tab
  --status     Show status of all active workers across repos
  --events     Show recent worker events
  --logs       Tail logs for a specific worker
  --stop       Terminate a specific worker
  --send       Send a message to a worker (use --type <type> for custom types)
  --messages   View pending messages (marks as read by default; use --peek to keep unread)
  --stage      Set worker stage (exploring, planning, implementing, testing, pr_creating,
               ci_waiting, review_waiting, review_responding, merge_conflicts, done, blocked)
  --help       Show this help message

Environment:
  MAIN_BRANCH    Base branch for new branches (default: main)
  WORKTREE_BASE  Directory for worktrees (default: ~/.worktrees)
  SPAWN_DELAY    Delay between spawns in seconds (default: 0.5)
EOF
    exit 1
}

# ============================================================================
# SQLite Database Functions
# ============================================================================

# Initialize the SQLite database with required tables
init_db() {
    mkdir -p "$(dirname "$DB_PATH")"
    sqlite3 "$DB_PATH" <<'SQL'
CREATE TABLE IF NOT EXISTS workers (
    id INTEGER PRIMARY KEY,
    repo_path TEXT,
    repo_name TEXT,
    issue_number INTEGER,
    branch TEXT,
    worktree_path TEXT,
    pid INTEGER,
    status TEXT DEFAULT 'starting',
    phase TEXT DEFAULT 'implementation',
    stage TEXT DEFAULT 'exploring',
    pr_number INTEGER,
    pr_url TEXT,
    started_at TEXT DEFAULT CURRENT_TIMESTAMP,
    updated_at TEXT DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(repo_path, branch)
);

CREATE TABLE IF NOT EXISTS events (
    id INTEGER PRIMARY KEY,
    worker_id INTEGER REFERENCES workers(id),
    event_type TEXT,
    message TEXT,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS completions (
    id INTEGER PRIMARY KEY,
    worker_id INTEGER REFERENCES workers(id),
    summary TEXT,
    files_changed TEXT,
    tests_added TEXT,
    pr_url TEXT,
    merged BOOLEAN,
    follow_up_issues TEXT,
    lessons_learned TEXT,
    completed_at TEXT DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS messages (
    id INTEGER PRIMARY KEY,
    worker_id INTEGER REFERENCES workers(id),
    message_type TEXT DEFAULT 'info',
    payload TEXT,
    read_at TEXT,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_workers_status ON workers(status);
CREATE INDEX IF NOT EXISTS idx_workers_repo ON workers(repo_path);
CREATE INDEX IF NOT EXISTS idx_events_worker ON events(worker_id);
CREATE INDEX IF NOT EXISTS idx_events_time ON events(created_at);
CREATE INDEX IF NOT EXISTS idx_messages_worker ON messages(worker_id);
CREATE INDEX IF NOT EXISTS idx_messages_unread ON messages(worker_id, read_at);
SQL

    # Migration: add stage column if it doesn't exist (for existing databases)
    local has_stage
    has_stage=$(sqlite3 "$DB_PATH" "SELECT COUNT(*) FROM pragma_table_info('workers') WHERE name='stage';")
    if [[ "$has_stage" -eq 0 ]]; then
        sqlite3 "$DB_PATH" "ALTER TABLE workers ADD COLUMN stage TEXT DEFAULT 'exploring';"
    fi
}

# Register a new worker in the database
# Returns the worker ID
db_register_worker() {
    local repo_path="$1"
    local repo_name="$2"
    local issue_number="$3"
    local branch="$4"
    local worktree_path="$5"
    local pid="$6"

    init_db

    # Use INSERT OR REPLACE to handle re-runs on the same branch
    sqlite3 "$DB_PATH" <<SQL
INSERT OR REPLACE INTO workers (repo_path, repo_name, issue_number, branch, worktree_path, pid, status, phase, stage, started_at, updated_at)
VALUES ('$repo_path', '$repo_name', ${issue_number:-NULL}, '$branch', '$worktree_path', $pid, 'starting', 'implementation', 'exploring', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP);
SQL

    # Return the worker ID
    sqlite3 "$DB_PATH" "SELECT id FROM workers WHERE repo_path='$repo_path' AND branch='$branch';"
}

# Update worker status
db_update_status() {
    local worker_id="$1"
    local status="$2"
    local phase="${3:-}"

    if [[ -n "$phase" ]]; then
        sqlite3 "$DB_PATH" "UPDATE workers SET status='$status', phase='$phase', updated_at=CURRENT_TIMESTAMP WHERE id=$worker_id;"
    else
        sqlite3 "$DB_PATH" "UPDATE workers SET status='$status', updated_at=CURRENT_TIMESTAMP WHERE id=$worker_id;"
    fi
}

# Update worker stage (granular progress tracking)
# Valid stages: exploring, planning, implementing, testing, pr_creating,
#               ci_waiting, review_waiting, review_responding, merge_conflicts, done, blocked
db_update_stage() {
    local worker_id="$1"
    local stage="$2"

    # Validate stage
    local valid_stages="exploring planning implementing testing pr_creating ci_waiting review_waiting review_responding merge_conflicts done blocked"
    if ! echo "$valid_stages" | grep -qw "$stage"; then
        echo "Error: Invalid stage '$stage'"
        echo "Valid stages: $valid_stages"
        return 1
    fi

    sqlite3 "$DB_PATH" "UPDATE workers SET stage='$stage', updated_at=CURRENT_TIMESTAMP WHERE id=$worker_id;"
    db_log_event "$worker_id" "stage_change" "Stage changed to: $stage"
}

# Update worker with PR information
db_update_pr() {
    local worker_id="$1"
    local pr_number="$2"
    local pr_url="$3"

    sqlite3 "$DB_PATH" "UPDATE workers SET pr_number=$pr_number, pr_url='$pr_url', status='pr_open', phase='ci_review', updated_at=CURRENT_TIMESTAMP WHERE id=$worker_id;"
}

# Log an event for a worker
db_log_event() {
    local worker_id="$1"
    local event_type="$2"
    local message="$3"

    sqlite3 "$DB_PATH" "INSERT INTO events (worker_id, event_type, message) VALUES ($worker_id, '$event_type', '$message');"
}

# Store completion summary
db_store_completion() {
    local worker_id="$1"
    local summary="$2"
    local files_changed="$3"
    local tests_added="$4"
    local pr_url="$5"
    local merged="$6"
    local follow_up_issues="$7"
    local lessons_learned="$8"

    sqlite3 "$DB_PATH" <<SQL
INSERT INTO completions (worker_id, summary, files_changed, tests_added, pr_url, merged, follow_up_issues, lessons_learned)
VALUES ($worker_id, '$summary', '$files_changed', '$tests_added', '$pr_url', $merged, '$follow_up_issues', '$lessons_learned');
SQL

    db_update_status "$worker_id" "done"
}

# Mark worker as failed
db_mark_failed() {
    local worker_id="$1"
    local reason="${2:-unknown}"

    db_update_status "$worker_id" "failed"
    db_log_event "$worker_id" "failed" "$reason"
}

# Parse issue argument which may be "issue" or "repo:issue"
# Sets PARSED_REPO and PARSED_ISSUE variables
parse_issue_arg() {
    local input="$1"
    PARSED_REPO=""
    PARSED_ISSUE=""

    if [[ "$input" == *:* ]]; then
        # repo:issue format
        PARSED_REPO="${input%%:*}"
        PARSED_ISSUE="${input#*:}"
    else
        # Just issue number - default to current repo
        PARSED_ISSUE="$input"
        if git rev-parse --show-toplevel &>/dev/null; then
            PARSED_REPO=$(basename "$(git rev-parse --show-toplevel)")
        fi
    fi
}

# Get worker ID by issue or PR number, optionally filtered by repo
# Searches both issue_number and pr_number columns
db_get_worker_by_issue() {
    local number="$1"
    local repo_name="${2:-}"

    local repo_filter=""
    if [[ -n "$repo_name" ]]; then
        repo_filter="AND repo_name='$repo_name'"
    fi

    sqlite3 "$DB_PATH" "SELECT id FROM workers WHERE (issue_number=$number OR pr_number=$number) $repo_filter AND status NOT IN ('done', 'failed') ORDER BY started_at DESC LIMIT 1;"
}

# Get worker ID by branch name
db_get_worker_by_branch() {
    local branch="$1"
    sqlite3 "$DB_PATH" "SELECT id FROM workers WHERE branch='$branch' AND status NOT IN ('done', 'failed') ORDER BY started_at DESC LIMIT 1;"
}

# Check if a worker process is still running
is_worker_alive() {
    local pid="$1"
    kill -0 "$pid" 2>/dev/null
}

# Clean up stale workers (processes that are no longer running)
db_cleanup_stale_workers() {
    init_db

    local stale_pids
    stale_pids=$(sqlite3 "$DB_PATH" "SELECT id, pid FROM workers WHERE status NOT IN ('done', 'failed');")

    while IFS='|' read -r worker_id pid; do
        if [[ -n "$worker_id" ]] && ! is_worker_alive "$pid"; then
            db_update_status "$worker_id" "failed"
            db_log_event "$worker_id" "cleanup" "Process $pid no longer running"
        fi
    done <<< "$stale_pids"
}

# Send a message to a worker
db_send_message() {
    local worker_id="$1"
    local message_type="$2"
    local payload="$3"

    # Escape single quotes in payload
    payload="${payload//\'/\'\'}"

    sqlite3 "$DB_PATH" "INSERT INTO messages (worker_id, message_type, payload) VALUES ($worker_id, '$message_type', '$payload');"
    db_log_event "$worker_id" "message_sent" "$message_type: $payload"
}

# Get unread messages for a worker
db_get_messages() {
    local worker_id="$1"
    local mark_read="${2:-false}"

    sqlite3 -separator '|' "$DB_PATH" "
        SELECT id, message_type, payload, created_at
        FROM messages
        WHERE worker_id = $worker_id AND read_at IS NULL
        ORDER BY created_at ASC;
    "

    if [[ "$mark_read" == "true" ]]; then
        sqlite3 "$DB_PATH" "UPDATE messages SET read_at = CURRENT_TIMESTAMP WHERE worker_id = $worker_id AND read_at IS NULL;"
    fi
}

# Mark specific message as read
db_mark_message_read() {
    local message_id="$1"
    sqlite3 "$DB_PATH" "UPDATE messages SET read_at = CURRENT_TIMESTAMP WHERE id = $message_id;"
}

# Get message count for a worker
db_get_message_count() {
    local worker_id="$1"
    sqlite3 "$DB_PATH" "SELECT COUNT(*) FROM messages WHERE worker_id = $worker_id AND read_at IS NULL;"
}

# ============================================================================
# Management Commands
# ============================================================================

# Show status of all active workers
cmd_status() {
    init_db
    db_cleanup_stale_workers

    echo "Active Workers:"
    echo "-------------------------------------------------------------------------------"
    printf "%-20s | %-6s | %-10s | %-17s | %s\n" "repo_name" "issue" "status" "stage" "mins_idle"
    echo "-------------------------------------------------------------------------------"

    sqlite3 -separator '|' "$DB_PATH" "
        SELECT repo_name, COALESCE(issue_number, '-'), status, COALESCE(stage, phase),
               CAST((julianday('now') - julianday(updated_at)) * 24 * 60 AS INTEGER)
        FROM workers
        WHERE status NOT IN ('done', 'failed')
        ORDER BY updated_at DESC;
    " | while IFS='|' read -r repo_name issue status stage mins_idle; do
        printf "%-20s | %-6s | %-10s | %-17s | %s\n" "$repo_name" "$issue" "$status" "$stage" "$mins_idle"
    done

    local count
    count=$(sqlite3 "$DB_PATH" "SELECT COUNT(*) FROM workers WHERE status NOT IN ('done', 'failed');")
    echo "-------------------------------------------------------------------------------"
    echo "Total active workers: $count"
}

# Show recent events
cmd_events() {
    local issue_filter="${1:-}"
    init_db

    echo "Recent Events:"
    echo "-------------------------------------------------------------------------------"

    local query
    if [[ -n "$issue_filter" ]]; then
        parse_issue_arg "$issue_filter"
        local where_clause="WHERE w.issue_number = $PARSED_ISSUE"
        if [[ -n "$PARSED_REPO" ]]; then
            where_clause="$where_clause AND w.repo_name = '$PARSED_REPO'"
        fi
        query="
            SELECT w.repo_name, w.issue_number, e.event_type, e.message, e.created_at
            FROM events e
            JOIN workers w ON e.worker_id = w.id
            $where_clause
            ORDER BY e.created_at DESC
            LIMIT 50;
        "
    else
        query="
            SELECT w.repo_name, w.issue_number, e.event_type, e.message, e.created_at
            FROM events e
            JOIN workers w ON e.worker_id = w.id
            ORDER BY e.created_at DESC
            LIMIT 50;
        "
    fi

    sqlite3 -separator '|' "$DB_PATH" "$query" | while IFS='|' read -r repo_name issue event_type message created_at; do
        local display_issue="${issue:-feature}"
        echo "[${repo_name} #${display_issue}] ${event_type}: ${message} (${created_at})"
    done
}

# Stream logs for a specific worker
cmd_logs() {
    local issue_arg="$1"

    if [[ -z "$issue_arg" ]]; then
        echo "Error: --logs requires an issue number (or repo:issue)"
        exit 1
    fi

    init_db
    parse_issue_arg "$issue_arg"

    local repo_filter=""
    if [[ -n "$PARSED_REPO" ]]; then
        repo_filter="AND repo_name='$PARSED_REPO'"
    fi

    # Find the worktree path for this issue/PR
    local worktree_path
    worktree_path=$(sqlite3 "$DB_PATH" "SELECT worktree_path FROM workers WHERE (issue_number=$PARSED_ISSUE OR pr_number=$PARSED_ISSUE) $repo_filter AND status NOT IN ('done', 'failed') ORDER BY started_at DESC LIMIT 1;")

    if [[ -z "$worktree_path" ]]; then
        echo "Error: No active worker found for #$PARSED_ISSUE${PARSED_REPO:+ in $PARSED_REPO}"
        exit 1
    fi

    # Get the worker_id for event queries
    local worker_id
    worker_id=$(sqlite3 "$DB_PATH" "SELECT id FROM workers WHERE (issue_number=$PARSED_ISSUE OR pr_number=$PARSED_ISSUE) $repo_filter AND status NOT IN ('done', 'failed') ORDER BY started_at DESC LIMIT 1;")

    # Claude Code stores conversation logs in ~/.claude/
    # For now, we'll show the events as a log stream
    echo "Events for #$PARSED_ISSUE${PARSED_REPO:+ ($PARSED_REPO)}:"
    echo "Worktree: $worktree_path"
    echo "-------------------------------------------------------------------------------"

    sqlite3 -separator '|' "$DB_PATH" "
        SELECT e.event_type, e.message, e.created_at
        FROM events e
        WHERE e.worker_id = $worker_id
        ORDER BY e.created_at ASC;
    " | while IFS='|' read -r event_type message created_at; do
        echo "[${created_at}] ${event_type}: ${message}"
    done

    # Also show current status
    echo "-------------------------------------------------------------------------------"
    local status phase pid
    read -r status phase pid <<< "$(sqlite3 -separator ' ' "$DB_PATH" "SELECT status, phase, pid FROM workers WHERE id=$worker_id;")"
    echo "Current status: $status | Phase: $phase | PID: $pid"
}

# Stop a specific worker
cmd_stop() {
    local issue_arg="$1"

    if [[ -z "$issue_arg" ]]; then
        echo "Error: --stop requires an issue number (or repo:issue)"
        exit 1
    fi

    init_db
    parse_issue_arg "$issue_arg"

    local repo_filter=""
    if [[ -n "$PARSED_REPO" ]]; then
        repo_filter="AND repo_name='$PARSED_REPO'"
    fi

    # Find the worker
    local worker_info
    worker_info=$(sqlite3 -separator '|' "$DB_PATH" "SELECT id, pid, repo_name FROM workers WHERE (issue_number=$PARSED_ISSUE OR pr_number=$PARSED_ISSUE) $repo_filter AND status NOT IN ('done', 'failed') ORDER BY started_at DESC LIMIT 1;")

    if [[ -z "$worker_info" ]]; then
        echo "Error: No active worker found for #$PARSED_ISSUE${PARSED_REPO:+ in $PARSED_REPO}"
        exit 1
    fi

    IFS='|' read -r worker_id pid repo_name <<< "$worker_info"

    echo "Stopping worker for #$PARSED_ISSUE (repo: $repo_name, PID: $pid)..."

    # Send SIGTERM first, then SIGKILL if needed
    if kill -TERM "$pid" 2>/dev/null; then
        sleep 2
        if is_worker_alive "$pid"; then
            echo "Worker still running, sending SIGKILL..."
            kill -KILL "$pid" 2>/dev/null || true
        fi
        db_update_status "$worker_id" "failed"
        db_log_event "$worker_id" "stopped" "Manually stopped by user"
        echo "Worker stopped."
    else
        echo "Process $pid is not running. Marking as failed."
        db_update_status "$worker_id" "failed"
        db_log_event "$worker_id" "cleanup" "Process not found when attempting to stop"
    fi
}

# Send a message to a worker
cmd_send() {
    local issue_arg="$1"
    shift
    local message="$*"

    if [[ -z "$issue_arg" ]]; then
        echo "Error: --send requires an issue number (or repo:issue)"
        echo "Usage: work --send <issue> <message>"
        echo "       work --send repo:issue <message>"
        echo "       work --send <issue> --type <type> <message>"
        exit 1
    fi

    if [[ -z "$message" ]]; then
        echo "Error: --send requires a message"
        exit 1
    fi

    init_db
    parse_issue_arg "$issue_arg"

    # Parse optional --type flag
    local message_type="info"
    if [[ "$message" == --type* ]]; then
        message_type="${message#--type }"
        message_type="${message_type%% *}"
        message="${message#--type $message_type }"
    fi

    # Find the worker
    local worker_id
    worker_id=$(db_get_worker_by_issue "$PARSED_ISSUE" "$PARSED_REPO")

    if [[ -z "$worker_id" ]]; then
        echo "Error: No active worker found for #$PARSED_ISSUE${PARSED_REPO:+ in $PARSED_REPO}"
        exit 1
    fi

    db_send_message "$worker_id" "$message_type" "$message"
    echo "Message sent to worker for #$PARSED_ISSUE${PARSED_REPO:+ ($PARSED_REPO)}"
    echo "  Type: $message_type"
    echo "  Message: $message"
}

# View messages for a worker (from worker's perspective)
# Messages are marked as read by default; use --peek to view without marking
cmd_messages() {
    local issue_arg="${1:-}"
    local peek_flag="${2:-}"

    init_db

    # If no issue specified, try to use current worker ID from environment
    local worker_id=""
    if [[ -n "$issue_arg" ]] && [[ "$issue_arg" != "--peek" ]]; then
        parse_issue_arg "$issue_arg"
        worker_id=$(db_get_worker_by_issue "$PARSED_ISSUE" "$PARSED_REPO")
        if [[ -z "$worker_id" ]]; then
            echo "Error: No active worker found for #$PARSED_ISSUE${PARSED_REPO:+ in $PARSED_REPO}"
            exit 1
        fi
    elif [[ -n "${WORK_WORKER_ID:-}" ]]; then
        worker_id="$WORK_WORKER_ID"
        # If first arg was --peek, capture it
        [[ "$issue_arg" == "--peek" ]] && peek_flag="--peek"
    else
        echo "Error: --messages requires an issue number (or repo:issue) or must be run from within a worker session"
        echo "Usage: work --messages [issue] [--peek]"
        echo "       work --messages [repo:issue] [--peek]"
        exit 1
    fi

    local count
    count=$(db_get_message_count "$worker_id")

    if [[ "$count" -eq 0 ]]; then
        echo "No unread messages."
        return 0
    fi

    echo "Unread Messages ($count):"
    echo "-------------------------------------------------------------------------------"

    # Mark as read by default, unless --peek is specified
    local should_mark="true"
    [[ "$peek_flag" == "--peek" ]] && should_mark="false"

    db_get_messages "$worker_id" "$should_mark" | while IFS='|' read -r msg_id msg_type payload created_at; do
        echo "[$created_at] ($msg_type) $payload"
    done

    echo "-------------------------------------------------------------------------------"
    if [[ "$should_mark" == "true" ]]; then
        echo "All messages marked as read."
    else
        echo "(Peek mode - messages NOT marked as read)"
    fi
}

# Set stage for a worker (worker self-reports its current stage)
cmd_stage() {
    local stage="${1:-}"
    local issue_arg="${2:-}"

    if [[ -z "$stage" ]]; then
        echo "Error: --stage requires a stage name"
        echo "Usage: work --stage <stage> [issue]"
        echo "       work --stage <stage> [repo:issue]"
        echo ""
        echo "Valid stages:"
        echo "  exploring        - Reading issue, understanding codebase"
        echo "  planning         - Designing approach, creating todo list"
        echo "  implementing     - Writing code"
        echo "  testing          - Running local tests"
        echo "  pr_creating      - Creating PR, writing description"
        echo "  ci_waiting       - PR created, waiting for CI to pass"
        echo "  review_waiting   - CI passed, waiting for review"
        echo "  review_responding - Addressing review feedback"
        echo "  merge_conflicts  - Resolving merge conflicts"
        echo "  done             - PR merged or issue closed"
        echo "  blocked          - Waiting on external dependency"
        exit 1
    fi

    init_db

    # Find the worker ID
    local worker_id=""
    if [[ -n "$issue_arg" ]]; then
        parse_issue_arg "$issue_arg"
        worker_id=$(db_get_worker_by_issue "$PARSED_ISSUE" "$PARSED_REPO")
        if [[ -z "$worker_id" ]]; then
            echo "Error: No active worker found for #$PARSED_ISSUE${PARSED_REPO:+ in $PARSED_REPO}"
            exit 1
        fi
    elif [[ -n "${WORK_WORKER_ID:-}" ]]; then
        worker_id="$WORK_WORKER_ID"
    else
        echo "Error: --stage requires an issue number (or repo:issue) or must be run from within a worker session"
        echo "Usage: work --stage <stage> [issue]"
        echo "       work --stage <stage> [repo:issue]"
        exit 1
    fi

    if db_update_stage "$worker_id" "$stage"; then
        echo "Stage updated to: $stage"
    fi
}

# ============================================================================
# Terminal Detection and Spawning
# ============================================================================

# Find Windows Terminal executable in WSL
find_wt_exe() {
    # Check if wt.exe is in PATH
    if command -v wt.exe &>/dev/null; then
        echo "wt.exe"
        return 0
    fi

    # Look in common Windows Terminal locations
    local wt_path
    for wt_path in /mnt/c/Users/*/AppData/Local/Microsoft/WindowsApps/wt.exe; do
        if [[ -x "$wt_path" ]]; then
            echo "$wt_path"
            return 0
        fi
    done

    return 1
}

# Detect terminal environment
# Sets SPAWN_METHOD to: "iterm2", "wsl", or ""
# Sets WT_EXE for WSL method
detect_spawn_method() {
    SPAWN_METHOD=""
    WT_EXE=""

    # Check for macOS + iTerm2
    if [[ "$(uname)" == "Darwin" ]]; then
        if osascript -e 'tell application "System Events" to (name of processes) contains "iTerm2"' 2>/dev/null | grep -q "true"; then
            SPAWN_METHOD="iterm2"
            return 0
        fi
    fi

    # Check for WSL + Windows Terminal
    if [[ -n "${WSL_DISTRO_NAME:-}" ]] || grep -qi microsoft /proc/version 2>/dev/null; then
        WT_EXE=$(find_wt_exe)
        if [[ -n "$WT_EXE" ]]; then
            SPAWN_METHOD="wsl"
            return 0
        fi
    fi

    return 1
}

# Check prerequisites for spawning
check_spawn_prerequisites() {
    if ! detect_spawn_method; then
        echo "Error: No supported terminal detected for spawning new tabs."
        echo "Supported environments:"
        echo "  - macOS with iTerm2 running"
        echo "  - WSL with Windows Terminal"
        echo ""
        echo "Use --here to run in current terminal instead."
        exit 1
    fi
}

# Spawn a single issue in a new iTerm2 tab
spawn_in_new_tab_iterm2() {
    local issue="$1"

    # Capture current directory
    local current_dir
    current_dir="$(pwd)"

    # Safely escape parameters for shell
    local escaped_issue escaped_dir escaped_script
    escaped_issue=$(printf '%q' "$issue")
    escaped_dir=$(printf '%q' "$current_dir")
    escaped_script=$(printf '%q' "${SCRIPT_DIR}/work")

    # Build the command to run in the new tab
    local cmd="${escaped_script} --here ${escaped_issue}"

    # Use AppleScript to create a new tab and run the command
    osascript <<EOF
tell application "iTerm2"
    tell current window
        create tab with default profile
        tell current session
            write text "cd ${escaped_dir} && ${cmd}"
        end tell
    end tell
end tell
EOF
}

# Spawn a single issue in a new Windows Terminal tab (WSL)
spawn_in_new_tab_wsl() {
    local issue="$1"

    # Capture current directory
    local current_dir
    current_dir="$(pwd)"

    # Get WSL distro name
    local distro="${WSL_DISTRO_NAME:-Ubuntu}"

    # Get user's default shell (zsh, bash, etc.)
    local user_shell
    user_shell=$(basename "${SHELL:-/bin/bash}")

    # Build the command to run in the new tab
    # Use single quotes for the outer command to preserve variables
    local cmd="cd '${current_dir}' && '${SCRIPT_DIR}/work' --here '${issue}'"

    # Use Windows Terminal to create a new tab running WSL
    # -w 0 = use current window, nt = new tab
    # Use wsl.exe to run the command - this avoids Windows Terminal's argument parsing issues
    "$WT_EXE" -w 0 nt wsl.exe -d "$distro" --cd "$current_dir" -- "$user_shell" -lic "$cmd"
}

# Spawn a single issue in a new terminal tab (dispatches based on environment)
spawn_in_new_tab() {
    local issue="$1"

    case "$SPAWN_METHOD" in
        iterm2)
            spawn_in_new_tab_iterm2 "$issue"
            ;;
        wsl)
            spawn_in_new_tab_wsl "$issue"
            ;;
        *)
            echo "Error: Unknown spawn method: $SPAWN_METHOD"
            exit 1
            ;;
    esac

    echo "Spawned new tab for: $issue"
}

# Slugify a string for use in branch names
slugify() {
    echo "$1" | tr '[:upper:]' '[:lower:]' | \
        sed -E 's/[^a-z0-9]+/-/g' | \
        sed -E 's/^-+|-+$//g' | \
        cut -c1-50
}

# Extract issue number from URL or direct input
parse_issue_input() {
    local input="$1"

    # GitHub issue or PR URL pattern
    if [[ "$input" =~ github\.com/([^/]+)/([^/]+)/(issues|pull)/([0-9]+) ]]; then
        ISSUE_OWNER="${BASH_REMATCH[1]}"
        ISSUE_REPO="${BASH_REMATCH[2]}"
        ISSUE_TYPE="${BASH_REMATCH[3]}"  # "issues" or "pull"
        ISSUE_NUMBER="${BASH_REMATCH[4]}"
        return 0
    fi

    # Plain issue number
    if [[ "$input" =~ ^[0-9]+$ ]]; then
        ISSUE_NUMBER="$input"
        ISSUE_TYPE="issues"
        # Try to get owner/repo from git remote
        local remote_url
        remote_url=$(git remote get-url origin 2>/dev/null || echo "")
        if [[ "$remote_url" =~ github\.com[:/]([^/]+)/([^/.]+) ]]; then
            ISSUE_OWNER="${BASH_REMATCH[1]}"
            ISSUE_REPO="${BASH_REMATCH[2]}"
        fi
        return 0
    fi

    return 1
}

# Detect which GitHub CLI to use based on owner/repo
detect_gh_cli() {
    local remote_url
    remote_url=$(git remote get-url origin 2>/dev/null || echo "")
    if [[ "$remote_url" == *"github.netflix.net"* ]]; then
        echo "ghe"
    else
        echo "gh"
    fi
}

# Fetch issue title from GitHub API
fetch_issue_title() {
    local gh_cli
    gh_cli=$(detect_gh_cli)
    if command -v "$gh_cli" &>/dev/null; then
        "$gh_cli" issue view "$ISSUE_NUMBER" --repo "${ISSUE_OWNER}/${ISSUE_REPO}" --json title -q .title 2>/dev/null || echo ""
    elif command -v curl &>/dev/null; then
        curl -s "https://api.github.com/repos/${ISSUE_OWNER}/${ISSUE_REPO}/issues/${ISSUE_NUMBER}" | \
            grep -o '"title"[[:space:]]*:[[:space:]]*"[^"]*"' | \
            sed 's/"title"[[:space:]]*:[[:space:]]*"\([^"]*\)"/\1/' || echo ""
    else
        echo ""
    fi
}

# Fetch PR branch name from GitHub API
fetch_pr_branch() {
    local gh_cli
    gh_cli=$(detect_gh_cli)
    if command -v "$gh_cli" &>/dev/null; then
        "$gh_cli" pr view "$ISSUE_NUMBER" --repo "${ISSUE_OWNER}/${ISSUE_REPO}" --json headRefName -q .headRefName 2>/dev/null || echo ""
    else
        echo ""
    fi
}

# Find existing branch for an issue
find_existing_branch() {
    local issue_num="$1"
    git branch -a --list "*issue-${issue_num}-*" 2>/dev/null | \
        sed 's/^[*+ ]*//' | \
        sed 's|remotes/origin/||' | \
        head -1
}

# Find existing worktree for a branch
find_existing_worktree() {
    local branch="$1"
    git worktree list --porcelain | \
        grep -A1 "^worktree" | \
        grep -B1 "branch refs/heads/${branch}$" | \
        grep "^worktree" | \
        sed 's/^worktree //' || true
}

# Run issue in current terminal (the original behavior)
run_here() {
    local input="$1"
    local description="${2:-}"

    ISSUE_NUMBER=""
    ISSUE_OWNER=""
    ISSUE_REPO=""
    ISSUE_TYPE=""
    BRANCH_NAME=""
    WORKTREE_PATH=""

    # Get repo name early for worktree path construction
    local repo_name
    repo_name=$(basename "$REPO_ROOT")

    # Try to parse as issue reference
    if parse_issue_input "$input"; then
        if [[ "$ISSUE_TYPE" == "pull" ]]; then
            echo "Found PR #${ISSUE_NUMBER}"
            if [[ -n "$ISSUE_OWNER" ]] && [[ -n "$ISSUE_REPO" ]]; then
                echo "Fetching PR branch from GitHub..."
                BRANCH_NAME=$(fetch_pr_branch)
            fi
            if [[ -n "$BRANCH_NAME" ]]; then
                echo "Found PR branch: $BRANCH_NAME"
            else
                echo "Could not fetch PR branch name"
                exit 1
            fi
        else
            echo "Found issue #${ISSUE_NUMBER}"
            BRANCH_NAME=$(find_existing_branch "$ISSUE_NUMBER")

            if [[ -n "$BRANCH_NAME" ]]; then
                echo "Found existing branch: $BRANCH_NAME"
            else
                if [[ -z "$description" ]] && [[ -n "$ISSUE_OWNER" ]] && [[ -n "$ISSUE_REPO" ]]; then
                    echo "Fetching issue title from GitHub..."
                    description=$(fetch_issue_title)
                fi

                if [[ -n "$description" ]]; then
                    BRANCH_NAME="issue-${ISSUE_NUMBER}-$(slugify "$description")"
                else
                    BRANCH_NAME="issue-${ISSUE_NUMBER}"
                fi
                echo "Will create new branch: $BRANCH_NAME"
            fi
        fi
    else
        description="$input"
        BRANCH_NAME="feature-$(slugify "$description")"

        if git show-ref --verify --quiet "refs/heads/${BRANCH_NAME}" 2>/dev/null; then
            echo "Found existing branch: $BRANCH_NAME"
        else
            echo "Will create new branch: $BRANCH_NAME"
        fi
    fi

    # Check for existing worktree
    WORKTREE_PATH=$(find_existing_worktree "$BRANCH_NAME")

    if [[ -n "$WORKTREE_PATH" ]]; then
        echo "Using existing worktree: $WORKTREE_PATH"
    else
        mkdir -p "${WORKTREE_BASE}/${repo_name}"
        WORKTREE_PATH="${WORKTREE_BASE}/${repo_name}/${BRANCH_NAME}"

        if [[ -d "$WORKTREE_PATH" ]]; then
            if git -C "$WORKTREE_PATH" rev-parse --git-dir &>/dev/null; then
                local current_branch
                current_branch=$(git -C "$WORKTREE_PATH" rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")
                if [[ "$current_branch" == "$BRANCH_NAME" ]]; then
                    echo "Using existing directory (not registered as worktree): $WORKTREE_PATH"
                else
                    echo "Error: Directory exists but is on branch '$current_branch', expected '$BRANCH_NAME'"
                    exit 1
                fi
            else
                echo "Error: Directory exists but is not a valid git directory: $WORKTREE_PATH"
                exit 1
            fi
        elif git show-ref --verify --quiet "refs/heads/${BRANCH_NAME}" 2>/dev/null; then
            echo "Creating worktree for existing branch..."
            git worktree add "$WORKTREE_PATH" "$BRANCH_NAME"
        elif git show-ref --verify --quiet "refs/remotes/origin/${BRANCH_NAME}" 2>/dev/null; then
            echo "Creating worktree for remote branch..."
            git worktree add "$WORKTREE_PATH" "$BRANCH_NAME"
        else
            echo "Creating worktree with new branch from ${MAIN_BRANCH}..."
            git worktree add -b "$BRANCH_NAME" "$WORKTREE_PATH" "$MAIN_BRANCH"
        fi
    fi

    # Build the prompt for Claude
    local task_ref=""
    if [[ -n "$ISSUE_NUMBER" ]] && [[ -n "$ISSUE_OWNER" ]] && [[ -n "$ISSUE_REPO" ]]; then
        if [[ "$ISSUE_TYPE" == "pull" ]]; then
            task_ref="GitHub PR https://github.com/${ISSUE_OWNER}/${ISSUE_REPO}/pull/${ISSUE_NUMBER}"
        else
            task_ref="GitHub issue https://github.com/${ISSUE_OWNER}/${ISSUE_REPO}/issues/${ISSUE_NUMBER}"
        fi
    elif [[ -n "$ISSUE_NUMBER" ]]; then
        task_ref="issue #${ISSUE_NUMBER}"
    else
        task_ref="${description}"
    fi

    # Detect GitHub CLI to use based on remote URL
    local gh_cli
    gh_cli=$(detect_gh_cli)

    local prompt
    prompt=$(cat <<EOF
Complete this task end-to-end: ${task_ref}

**IMPORTANT**: Read CLAUDE.md first for project-specific instructions (test commands, labels, coding standards, etc.)

## Workflow

### Phase 1: Implementation
1. Read CLAUDE.md to understand project conventions and commands
2. Read and understand the task requirements
3. Plan the implementation approach
4. Implement the changes with appropriate tests
5. Run tests locally using the command specified in CLAUDE.md
6. Commit your changes with descriptive commit messages

### Phase 2: Pull Request
1. Push your branch and open a PR using \`${gh_cli} pr create\`
2. Link the PR to the issue if applicable

### Phase 3: CI & Review Loop
Repeat until the PR is ready to merge:

1. **Wait for CI**: Use \`${gh_cli} pr checks --watch\` to monitor CI status
2. **Handle CI failures**: If CI fails, investigate logs with \`${gh_cli} pr checks\` and \`${gh_cli} run view\`, fix issues, push fixes
3. **Check for reviews**: Use \`${gh_cli} pr view --comments\` and \`${gh_cli} api repos/{owner}/{repo}/pulls/{pr}/reviews\` to check for review feedback
4. **Address critical feedback**: Fix any issues marked as "REQUEST_CHANGES" or critical comments. Respond to review comments as you address them.
5. **Re-request review if needed**: After addressing feedback, re-request review if appropriate

### Phase 4: Merge
Once CI passes and there are no blocking reviews:
1. Merge the PR using \`${gh_cli} pr merge <PR-NUMBER> --squash\`
2. Confirm the merge succeeded

### Phase 5: Follow-up Issues (REQUIRED)
**After merging, you MUST review for follow-up issues.** This is a critical step that ensures technical debt and improvements are tracked.

**Check these sources for follow-up items:**
1. **PR review comments** - Any suggestions marked "consider for future" or "nice to have"
2. **Code review feedback** - Items you acknowledged but didn't implement in this PR
3. **TODOs you added** - Any TODO/FIXME comments you wrote during implementation
4. **Incomplete integrations** - Features that work but aren't fully integrated everywhere
5. **Missing edge cases** - Test coverage gaps or error handling improvements noted
6. **Performance optimizations** - Potential improvements identified but not prioritized
7. **Documentation gaps** - API docs, README updates, or examples that should be added

**For each follow-up item, create an issue with:**
- Clear title describing the work
- Background context (reference this PR)
- Specific problem or improvement
- Proposed solution if known

**Use labels defined in CLAUDE.md** when creating issues. If no labels are defined, use sensible defaults like: bug, enhancement, documentation.

**If no follow-up issues are needed, explicitly confirm:** "Reviewed for follow-up issues: none identified."

### Phase 6: Completion Summary (REQUIRED)
Before exiting, write a completion summary to help with future reference:

\`\`\`bash
# Update worker status to done and record completion summary
sqlite3 "\${WORK_DB_PATH:-\${HOME}/.worktrees/work-sessions.db}" "UPDATE workers SET status='done', updated_at=CURRENT_TIMESTAMP WHERE id=\${WORK_WORKER_ID:-0};"
\`\`\`

Then output a summary including:
- **What was accomplished**: Brief description of the completed work
- **Files changed**: List of key files modified
- **Key decisions made**: Any architectural or implementation choices
- **Follow-up issues created**: Links to any issues created for future work

## Guidelines
- Be thorough but avoid over-engineering
- Write clear commit messages explaining the "why"
- Keep PR description updated with significant changes
- Follow any project-specific guidelines in CLAUDE.md
- If blocked by external factors (permissions, unclear requirements), explain and stop
- **Check for messages**: Periodically check for messages from the parent session:
  \`\`\`bash
  work --messages  # Uses WORK_WORKER_ID from environment
  \`\`\`
  Messages may contain priority changes, additional context, or instructions.
EOF
)

    # Set terminal tab/window title (works for iTerm2 and Windows Terminal)
    local title=""
    if [[ -n "$ISSUE_NUMBER" ]]; then
        title="Issue #${ISSUE_NUMBER}"
    else
        title="${description:0:30}"
    fi
    printf '\033]0;%s\007' "$title"

    echo ""
    echo "  Worktree: $WORKTREE_PATH"
    echo "  Branch:   $BRANCH_NAME"
    echo "  Task:     $task_ref"
    echo ""

    # Check if we're already inside a Claude Code session
    if [[ -n "${CLAUDE_CODE:-}" ]]; then
        echo "Already in Claude Code session. Outputting task info:"
        echo ""
        echo "=== TASK PROMPT ==="
        echo "$prompt"
        echo "=== END PROMPT ==="
        echo ""
        echo "Worktree ready at: $WORKTREE_PATH"
        exit 0
    fi

    # Register worker in database
    local worker_id
    worker_id=$(db_register_worker "$REPO_ROOT" "$repo_name" "$ISSUE_NUMBER" "$BRANCH_NAME" "$WORKTREE_PATH" "$$")
    db_log_event "$worker_id" "started" "Worker started for ${task_ref}"
    db_update_status "$worker_id" "running" "implementation"

    # Export worker ID for potential use by hooks or child processes
    export WORK_WORKER_ID="$worker_id"
    export WORK_DB_PATH="$DB_PATH"

    echo "Starting Claude Code session..."
    echo "  Worker ID: $worker_id"

    cd "$WORKTREE_PATH"
    exec claude --dangerously-skip-permissions "$prompt"
}

# Main logic
main() {
    if [[ $# -lt 1 ]]; then
        usage
    fi

    case "$1" in
        --help|-h)
            usage
            ;;
        --status)
            cmd_status
            ;;
        --events)
            shift
            cmd_events "$@"
            ;;
        --logs)
            shift
            cmd_logs "$1"
            ;;
        --stop)
            shift
            cmd_stop "$1"
            ;;
        --send)
            shift
            cmd_send "$@"
            ;;
        --messages)
            shift
            cmd_messages "$@"
            ;;
        --stage)
            shift
            cmd_stage "$@"
            ;;
        --here)
            # Run in current terminal
            shift
            if [[ $# -lt 1 ]]; then
                echo "Error: --here requires an issue or description"
                exit 1
            fi
            run_here "$@"
            ;;
        *)
            # Default: spawn in new tab(s)
            check_spawn_prerequisites

            # Spawn each argument in its own tab
            for issue in "$@"; do
                spawn_in_new_tab "$issue"
                if [[ $# -gt 1 ]]; then
                    sleep "$SPAWN_DELAY"
                fi
            done

            if [[ $# -gt 1 ]]; then
                echo ""
                echo "Spawned $# tabs for: $*"
            fi
            ;;
    esac
}

main "$@"
