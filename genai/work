#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.11"
# dependencies = [
#     "click>=8.0",
#     "tomli>=2.0",
# ]
# ///
"""
work - Start Claude Code session(s) for GitHub issue(s) or JIRA tickets.

By default, spawns each issue in a new terminal tab:
  - macOS: Uses iTerm2
  - WSL: Uses Windows Terminal
Use --here to run in the current terminal instead.
"""

from __future__ import annotations

import os
import re
import json
import signal
import sqlite3
import subprocess
import sys
import time
from contextlib import contextmanager
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Optional, Iterator

import click

# =============================================================================
# Configuration
# =============================================================================

@dataclass
class Config:
    """Application configuration from environment variables."""
    worktree_base: Path = field(default_factory=lambda: Path.home() / ".worktrees")
    main_branch: str = "main"
    spawn_delay: float = 0.5

    def __post_init__(self):
        self.worktree_base = Path(os.environ.get("WORKTREE_BASE", self.worktree_base))
        self.main_branch = os.environ.get("MAIN_BRANCH", self.main_branch)
        self.spawn_delay = float(os.environ.get("SPAWN_DELAY", self.spawn_delay))

    @property
    def db_path(self) -> Path:
        return self.worktree_base / "work-sessions.db"


config = Config()


@dataclass
class WorkConfig:
    """Project-specific work configuration from .work.toml."""
    worker_guidelines: str = ""
    review_guidelines: str = ""
    review_strictness: str = "normal"  # "strict", "normal", "lenient"
    require_pre_merge_review: bool = True


def load_work_config() -> WorkConfig:
    """Load .work.toml from repo root if it exists."""
    import tomli

    repo_root = get_repo_root()
    if not repo_root:
        return WorkConfig()

    for name in [".work.toml", "work.toml"]:
        config_path = repo_root / name
        if config_path.exists():
            try:
                with open(config_path, "rb") as f:
                    data = tomli.load(f)
                return WorkConfig(
                    worker_guidelines=data.get("worker_guidelines", ""),
                    review_guidelines=data.get("review_guidelines", ""),
                    review_strictness=data.get("review_strictness", "normal"),
                    require_pre_merge_review=data.get("require_pre_merge_review", True),
                )
            except Exception as e:
                click.echo(f"Warning: Failed to parse {config_path}: {e}", err=True)

    return WorkConfig()


# Default review guidelines (used when not overridden in config)
DEFAULT_REVIEW_GUIDELINES = """
Focus on bugs actually introduced by these changes:

1. **Logic errors**: Off-by-one, null/undefined handling, incorrect conditions
2. **Security**: Injection vulnerabilities, auth bypasses, data exposure
3. **Resource leaks**: Unclosed files, connections, memory
4. **Error handling**: Unhandled exceptions, missing validation
5. **Breaking changes**: Public API modifications without backwards compatibility

Ignore: Style/formatting, pre-existing issues, minor nitpicks.
"""


# Valid stages for worker progress tracking
VALID_STAGES = [
    "exploring", "planning", "implementing", "testing", "pr_creating",
    "ci_waiting", "review_waiting", "review_responding", "merge_conflicts",
    "done", "blocked"
]

# =============================================================================
# Database Layer
# =============================================================================

SCHEMA = """
CREATE TABLE IF NOT EXISTS workers (
    id INTEGER PRIMARY KEY,
    repo_path TEXT,
    repo_name TEXT,
    issue_number INTEGER,
    branch TEXT,
    worktree_path TEXT,
    pid INTEGER,
    status TEXT DEFAULT 'starting',
    phase TEXT DEFAULT 'implementation',
    stage TEXT DEFAULT 'exploring',
    pr_number INTEGER,
    pr_url TEXT,
    jira_key TEXT,
    issue_source TEXT DEFAULT 'github',
    started_at TEXT DEFAULT CURRENT_TIMESTAMP,
    updated_at TEXT DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(repo_path, branch)
);

CREATE TABLE IF NOT EXISTS events (
    id INTEGER PRIMARY KEY,
    worker_id INTEGER REFERENCES workers(id),
    event_type TEXT,
    message TEXT,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS completions (
    id INTEGER PRIMARY KEY,
    worker_id INTEGER REFERENCES workers(id),
    summary TEXT,
    files_changed TEXT,
    tests_added TEXT,
    pr_url TEXT,
    merged BOOLEAN,
    follow_up_issues TEXT,
    lessons_learned TEXT,
    completed_at TEXT DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS messages (
    id INTEGER PRIMARY KEY,
    worker_id INTEGER REFERENCES workers(id),
    message_type TEXT DEFAULT 'info',
    payload TEXT,
    read_at TEXT,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_workers_status ON workers(status);
CREATE INDEX IF NOT EXISTS idx_workers_repo ON workers(repo_path);
CREATE INDEX IF NOT EXISTS idx_events_worker ON events(worker_id);
CREATE INDEX IF NOT EXISTS idx_events_time ON events(created_at);
CREATE INDEX IF NOT EXISTS idx_messages_worker ON messages(worker_id);
CREATE INDEX IF NOT EXISTS idx_messages_unread ON messages(worker_id, read_at);
"""


@contextmanager
def get_db() -> Iterator[sqlite3.Connection]:
    """Get a database connection with row factory."""
    config.worktree_base.mkdir(parents=True, exist_ok=True)
    conn = sqlite3.connect(config.db_path)
    conn.row_factory = sqlite3.Row
    try:
        yield conn
        conn.commit()
    finally:
        conn.close()


def init_db() -> None:
    """Initialize the database with required tables and run migrations."""
    with get_db() as conn:
        conn.executescript(SCHEMA)

        # Check for existing columns and migrate if needed
        cursor = conn.execute("PRAGMA table_info(workers)")
        columns = {row["name"] for row in cursor.fetchall()}

        if "stage" not in columns:
            conn.execute("ALTER TABLE workers ADD COLUMN stage TEXT DEFAULT 'exploring'")
        if "jira_key" not in columns:
            conn.execute("ALTER TABLE workers ADD COLUMN jira_key TEXT")
        if "issue_source" not in columns:
            conn.execute("ALTER TABLE workers ADD COLUMN issue_source TEXT DEFAULT 'github'")


def db_register_worker(
    repo_path: str,
    repo_name: str,
    issue_number: Optional[int],
    branch: str,
    worktree_path: str,
    pid: int,
    jira_key: Optional[str] = None,
    issue_source: str = "github"
) -> int:
    """Register a new worker in the database. Returns the worker ID."""
    init_db()
    with get_db() as conn:
        conn.execute("""
            INSERT OR REPLACE INTO workers
            (repo_path, repo_name, issue_number, branch, worktree_path, pid,
             status, phase, stage, jira_key, issue_source, started_at, updated_at)
            VALUES (?, ?, ?, ?, ?, ?, 'starting', 'implementation', 'exploring', ?, ?,
                    CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
        """, (repo_path, repo_name, issue_number, branch, worktree_path, pid,
              jira_key, issue_source))

        cursor = conn.execute(
            "SELECT id FROM workers WHERE repo_path=? AND branch=?",
            (repo_path, branch)
        )
        return cursor.fetchone()["id"]


def db_update_status(worker_id: int, status: str, phase: Optional[str] = None) -> None:
    """Update worker status and optional phase."""
    with get_db() as conn:
        if phase:
            conn.execute(
                "UPDATE workers SET status=?, phase=?, updated_at=CURRENT_TIMESTAMP WHERE id=?",
                (status, phase, worker_id)
            )
        else:
            conn.execute(
                "UPDATE workers SET status=?, updated_at=CURRENT_TIMESTAMP WHERE id=?",
                (status, worker_id)
            )


def db_update_stage(worker_id: int, stage: str) -> None:
    """Update worker stage with validation."""
    if stage not in VALID_STAGES:
        raise click.ClickException(
            f"Invalid stage '{stage}'. Valid stages: {', '.join(VALID_STAGES)}"
        )
    with get_db() as conn:
        conn.execute(
            "UPDATE workers SET stage=?, updated_at=CURRENT_TIMESTAMP WHERE id=?",
            (stage, worker_id)
        )
    db_log_event(worker_id, "stage_change", f"Stage changed to: {stage}")


def db_update_pr(worker_id: int, pr_number: int, pr_url: str) -> None:
    """Update worker with PR information."""
    with get_db() as conn:
        conn.execute("""
            UPDATE workers
            SET pr_number=?, pr_url=?, status='pr_open', phase='ci_review',
                updated_at=CURRENT_TIMESTAMP
            WHERE id=?
        """, (pr_number, pr_url, worker_id))


def db_log_event(worker_id: int, event_type: str, message: str) -> None:
    """Log an event for a worker."""
    with get_db() as conn:
        conn.execute(
            "INSERT INTO events (worker_id, event_type, message) VALUES (?, ?, ?)",
            (worker_id, event_type, message)
        )


def db_store_completion(
    worker_id: int,
    summary: str,
    files_changed: str,
    tests_added: str,
    pr_url: str,
    merged: bool,
    follow_up_issues: str,
    lessons_learned: str
) -> None:
    """Store completion summary and mark worker as done."""
    with get_db() as conn:
        conn.execute("""
            INSERT INTO completions
            (worker_id, summary, files_changed, tests_added, pr_url, merged,
             follow_up_issues, lessons_learned)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        """, (worker_id, summary, files_changed, tests_added, pr_url, merged,
              follow_up_issues, lessons_learned))
    db_update_status(worker_id, "done")


def db_mark_failed(worker_id: int, reason: str = "unknown") -> None:
    """Mark worker as failed."""
    db_update_status(worker_id, "failed")
    db_log_event(worker_id, "failed", reason)


def db_get_worker_by_issue(identifier: str, repo_name: Optional[str] = None) -> Optional[int]:
    """Get worker ID by issue number, PR number, or JIRA key."""
    init_db()
    with get_db() as conn:
        repo_filter = "AND repo_name=?" if repo_name else ""
        params: list = []

        # Check if it looks like a JIRA key
        if re.match(r'^[A-Z]+-[0-9]+$', identifier):
            query = f"""
                SELECT id FROM workers
                WHERE jira_key=? {repo_filter}
                AND status NOT IN ('done', 'failed')
                ORDER BY started_at DESC LIMIT 1
            """
            params = [identifier]
        else:
            # GitHub issue/PR lookup
            try:
                num = int(identifier)
                query = f"""
                    SELECT id FROM workers
                    WHERE (issue_number=? OR pr_number=?) {repo_filter}
                    AND status NOT IN ('done', 'failed')
                    ORDER BY started_at DESC LIMIT 1
                """
                params = [num, num]
            except ValueError:
                return None

        if repo_name:
            params.append(repo_name)

        cursor = conn.execute(query, params)
        row = cursor.fetchone()
        return row["id"] if row else None


def db_get_worker_by_branch(branch: str) -> Optional[int]:
    """Get worker ID by branch name."""
    with get_db() as conn:
        cursor = conn.execute("""
            SELECT id FROM workers
            WHERE branch=? AND status NOT IN ('done', 'failed')
            ORDER BY started_at DESC LIMIT 1
        """, (branch,))
        row = cursor.fetchone()
        return row["id"] if row else None


def is_worker_alive(pid: int) -> bool:
    """Check if a worker process is still running."""
    try:
        os.kill(pid, 0)
        return True
    except (OSError, ProcessLookupError):
        return False


def db_cleanup_stale_workers() -> None:
    """Mark workers as failed if their processes are no longer running."""
    with get_db() as conn:
        cursor = conn.execute("""
            SELECT id, pid FROM workers
            WHERE status NOT IN ('done', 'failed') AND pid IS NOT NULL
        """)
        for row in cursor.fetchall():
            if not is_worker_alive(row["pid"]):
                db_mark_failed(row["id"], "Process no longer running")


def db_send_message(worker_id: int, message_type: str, payload: str) -> None:
    """Send a message to a worker."""
    with get_db() as conn:
        conn.execute(
            "INSERT INTO messages (worker_id, message_type, payload) VALUES (?, ?, ?)",
            (worker_id, message_type, payload)
        )
    db_log_event(worker_id, "message_sent", f"[{message_type}] {payload[:50]}...")


def db_get_messages(worker_id: int, mark_read: bool = True) -> list[dict]:
    """Get unread messages for a worker, optionally marking them as read."""
    with get_db() as conn:
        cursor = conn.execute("""
            SELECT id, message_type, payload, created_at
            FROM messages
            WHERE worker_id=? AND read_at IS NULL
            ORDER BY created_at ASC
        """, (worker_id,))
        messages = [dict(row) for row in cursor.fetchall()]

        if mark_read and messages:
            msg_ids = [m["id"] for m in messages]
            placeholders = ",".join("?" * len(msg_ids))
            conn.execute(
                f"UPDATE messages SET read_at=CURRENT_TIMESTAMP WHERE id IN ({placeholders})",
                msg_ids
            )

        return messages


def db_get_message_count(worker_id: int) -> int:
    """Get count of unread messages for a worker."""
    with get_db() as conn:
        cursor = conn.execute(
            "SELECT COUNT(*) as count FROM messages WHERE worker_id=? AND read_at IS NULL",
            (worker_id,)
        )
        return cursor.fetchone()["count"]


# =============================================================================
# Issue Parsing
# =============================================================================

@dataclass
class ParsedIssue:
    """Parsed issue information."""
    owner: Optional[str] = None
    repo: Optional[str] = None
    issue_type: Optional[str] = None  # "issues" or "pull"
    number: Optional[int] = None
    jira_key: Optional[str] = None
    description: Optional[str] = None


def parse_github_url(url: str) -> Optional[ParsedIssue]:
    """Parse a GitHub issue or PR URL."""
    # Match: https://github.com/owner/repo/issues/42 or /pull/42
    match = re.match(
        r'https?://(?:www\.)?github(?:\.netflix)?\.(?:com|net)/([^/]+)/([^/]+)/(issues|pull)/(\d+)',
        url
    )
    if match:
        return ParsedIssue(
            owner=match.group(1),
            repo=match.group(2),
            issue_type=match.group(3),
            number=int(match.group(4))
        )
    return None


def parse_jira_key(input_str: str) -> Optional[str]:
    """Parse a JIRA key from input (URL or plain key)."""
    # JIRA URL: https://netflix.atlassian.net/browse/AIE-123
    url_match = re.search(r'atlassian\.net/browse/([A-Z]+-\d+)', input_str)
    if url_match:
        return url_match.group(1)

    # Plain JIRA key: AIE-123
    if re.match(r'^[A-Z]+-\d+$', input_str):
        return input_str

    return None


def parse_issue_arg(input_str: str) -> tuple[str, Optional[str]]:
    """
    Parse issue argument with optional repo prefix.
    Returns (issue, repo) tuple where repo may be None.
    Supports: 42, repo:42, AIE-123
    """
    if ":" in input_str and not input_str.startswith("http"):
        repo, issue = input_str.split(":", 1)
        return issue, repo
    return input_str, None


def get_repo_root() -> Optional[Path]:
    """Get the git repository root."""
    try:
        result = subprocess.run(
            ["git", "rev-parse", "--show-toplevel"],
            capture_output=True, text=True, check=True
        )
        return Path(result.stdout.strip())
    except subprocess.CalledProcessError:
        return None


def get_current_repo_name() -> Optional[str]:
    """Get the current repository name."""
    root = get_repo_root()
    return root.name if root else None


def detect_gh_cli() -> str:
    """Detect which GitHub CLI to use based on remote URL."""
    try:
        result = subprocess.run(
            ["git", "remote", "get-url", "origin"],
            capture_output=True, text=True, check=True
        )
        if "github.netflix.net" in result.stdout:
            return "ghe"
    except subprocess.CalledProcessError:
        pass
    return "gh"


def fetch_issue_title(issue_number: int, gh_cli: str = "gh") -> Optional[str]:
    """Fetch issue title from GitHub."""
    try:
        result = subprocess.run(
            [gh_cli, "issue", "view", str(issue_number), "--json", "title"],
            capture_output=True, text=True, check=True
        )
        data = json.loads(result.stdout)
        return data.get("title")
    except (subprocess.CalledProcessError, json.JSONDecodeError):
        return None


def fetch_pr_branch(pr_number: int, gh_cli: str = "gh") -> Optional[str]:
    """Fetch the branch name for a PR."""
    try:
        result = subprocess.run(
            [gh_cli, "pr", "view", str(pr_number), "--json", "headRefName"],
            capture_output=True, text=True, check=True
        )
        data = json.loads(result.stdout)
        return data.get("headRefName")
    except (subprocess.CalledProcessError, json.JSONDecodeError):
        return None


def fetch_jira_summary(jira_key: str) -> Optional[str]:
    """Fetch JIRA issue summary using acli."""
    try:
        result = subprocess.run(
            ["acli", "jira", "workitem", "view", jira_key, "--json"],
            capture_output=True, text=True, check=True
        )
        data = json.loads(result.stdout)
        return data.get("fields", {}).get("summary")
    except (subprocess.CalledProcessError, json.JSONDecodeError, FileNotFoundError):
        return None


def slugify(text: str, max_length: int = 50) -> str:
    """Convert text to a URL-friendly slug."""
    # Lowercase and replace non-alphanumeric with hyphens
    slug = re.sub(r'[^a-z0-9]+', '-', text.lower())
    # Remove leading/trailing hyphens
    slug = slug.strip('-')
    # Truncate
    if len(slug) > max_length:
        slug = slug[:max_length].rsplit('-', 1)[0]
    return slug


def find_existing_branch(pattern: str) -> Optional[str]:
    """Find an existing branch matching a pattern."""
    try:
        result = subprocess.run(
            ["git", "branch", "-a", "--list", f"*{pattern}*"],
            capture_output=True, text=True, check=True
        )
        branches = result.stdout.strip().split('\n')
        for branch in branches:
            # Strip whitespace and branch markers (* for current branch, + for worktree)
            branch = branch.strip().lstrip('*+ ')
            if branch:
                # Remove remotes/origin/ prefix if present
                branch = re.sub(r'^remotes/origin/', '', branch)
                return branch
    except subprocess.CalledProcessError:
        pass
    return None


def find_existing_worktree(branch: str) -> Optional[Path]:
    """Find existing worktree for a branch."""
    try:
        result = subprocess.run(
            ["git", "worktree", "list", "--porcelain"],
            capture_output=True, text=True, check=True
        )
        worktree_path = None
        for line in result.stdout.split('\n'):
            if line.startswith('worktree '):
                worktree_path = Path(line.split(' ', 1)[1])
            elif line.startswith('branch ') and branch in line:
                return worktree_path
    except subprocess.CalledProcessError:
        pass
    return None


# =============================================================================
# Terminal Spawning
# =============================================================================

def detect_spawn_method() -> Optional[str]:
    """Detect available terminal spawning method."""
    # Check for iTerm2 on macOS
    if sys.platform == "darwin":
        try:
            result = subprocess.run(
                ["osascript", "-e", 'tell application "System Events" to (name of processes) contains "iTerm2"'],
                capture_output=True, text=True, check=True
            )
            if "true" in result.stdout.lower():
                return "iterm2"
        except subprocess.CalledProcessError:
            pass

    # Check for WSL
    if os.environ.get("WSL_DISTRO_NAME") or os.path.exists("/proc/version"):
        try:
            with open("/proc/version") as f:
                if "microsoft" in f.read().lower():
                    # Find wt.exe
                    for path in [
                        "/mnt/c/Users/*/AppData/Local/Microsoft/WindowsApps/wt.exe",
                        "/mnt/c/Program Files/WindowsApps/*/wt.exe"
                    ]:
                        import glob
                        matches = glob.glob(path)
                        if matches:
                            return "wsl"
        except (IOError, OSError):
            pass

    return None


def spawn_iterm2(issue: str, script_path: Path, cwd: Path) -> None:
    """Spawn a new iTerm2 tab with the work command."""
    cmd = f"cd '{cwd}' && '{script_path}' --here '{issue}'"

    applescript = f'''
tell application "iTerm2"
    tell current window
        create tab with default profile
        tell current session
            write text "{cmd}"
        end tell
    end tell
end tell
'''
    subprocess.run(["osascript", "-e", applescript], check=True)


def spawn_wsl(issue: str, script_path: Path, cwd: Path) -> None:
    """Spawn a new Windows Terminal tab via WSL."""
    distro = os.environ.get("WSL_DISTRO_NAME", "Ubuntu")
    shell = os.path.basename(os.environ.get("SHELL", "/bin/bash"))

    cmd = f"cd '{cwd}' && '{script_path}' --here '{issue}'"

    # Find wt.exe
    import glob
    wt_paths = glob.glob("/mnt/c/Users/*/AppData/Local/Microsoft/WindowsApps/wt.exe")
    if not wt_paths:
        raise click.ClickException("Windows Terminal (wt.exe) not found")

    wt_exe = wt_paths[0]
    subprocess.run([
        wt_exe, "-w", "0", "nt",
        "wsl.exe", "-d", distro, "--cd", str(cwd), "--",
        shell, "-lic", cmd
    ], check=True)


def spawn_in_new_tab(issue: str) -> None:
    """Spawn work command in a new terminal tab."""
    method = detect_spawn_method()
    if not method:
        raise click.ClickException(
            "No supported terminal found. Use --here to run in current terminal.\n"
            "Supported: iTerm2 (macOS), Windows Terminal (WSL)"
        )

    script_path = Path(__file__).resolve()
    cwd = Path.cwd()

    if method == "iterm2":
        spawn_iterm2(issue, script_path, cwd)
    elif method == "wsl":
        spawn_wsl(issue, script_path, cwd)


# =============================================================================
# Prompt Generation
# =============================================================================

def generate_prompt(
    task_ref: str,
    gh_cli: str,
    jira_key: Optional[str] = None
) -> str:
    """Generate the Claude Code prompt."""

    # Load project config for worker guidelines
    work_config = load_work_config()

    jira_instructions = ""
    jira_phase1_note = ""
    if jira_key:
        jira_instructions = f"""
**For JIRA issue details**: Use the Atlassian MCP tools to fetch full issue details:
- Use `getJiraIssue` with cloudId="netflix.atlassian.net" and issueIdOrKey="{jira_key}"
- Review the issue description, acceptance criteria, and any comments
"""
        jira_phase1_note = " - fetch JIRA issue details using MCP tools"

    # Build worker guidelines section if configured
    worker_guidelines_section = ""
    if work_config.worker_guidelines.strip():
        worker_guidelines_section = f"\n{work_config.worker_guidelines}"

    return f"""Complete this task end-to-end: {task_ref}

**IMPORTANT**: Read CLAUDE.md first for project-specific instructions (test commands, labels, coding standards, etc.)
{jira_instructions}
## Workflow

### Phase 1: Implementation
1. Read CLAUDE.md to understand project conventions and commands
2. Read and understand the task requirements{jira_phase1_note}
3. Plan the implementation approach
4. Implement the changes with appropriate tests
5. Run tests locally using the command specified in CLAUDE.md
6. Commit your changes with descriptive commit messages

### Phase 2: Pull Request
1. **Run self-review before creating PR (REQUIRED):**
   ```bash
   work --review
   ```
   This reviews your changes and blocks if issues are found.
   - If issues found: fix them, commit, and run `work --review` again
   - Only proceed to PR creation after review passes

2. Push your branch and open a PR using `{gh_cli} pr create`
3. Link the PR to the issue if applicable

### Phase 3: CI & Review Loop
Repeat until the PR is ready to merge:

1. **Wait for CI**: Use `{gh_cli} pr checks --watch` to monitor CI status
2. **Handle CI failures**: If CI fails, investigate logs with `{gh_cli} pr checks` and `{gh_cli} run view`, fix issues, push fixes
3. **Check for reviews**: Use `{gh_cli} pr view --comments` and `{gh_cli} api repos/{{owner}}/{{repo}}/pulls/{{pr}}/reviews` to check for review feedback
4. **Address critical feedback**: Fix any issues marked as "REQUEST_CHANGES" or critical comments. Respond to review comments as you address them.
5. **Re-request review if needed**: After addressing feedback, re-request review if appropriate

### Phase 4: Merge
**IMPORTANT: NEVER merge without at least one approving review.**

Prerequisites before merging:
- CI checks must pass
- At least one reviewer must have APPROVED the PR (not just "Requested")
- No reviews with "REQUEST_CHANGES" status remain unaddressed
- **Self-review must pass:**
  ```bash
  work --review --pre-merge
  ```

If reviewers are assigned but haven't reviewed yet, WAIT for their review. Do NOT merge PRs that only show "Requested" reviewers with no actual approvals.

Once you have approval and self-review passes:
1. Merge the PR using `{gh_cli} pr merge <PR-NUMBER> --squash`
2. Confirm the merge succeeded

### Phase 5: Follow-up Issues (REQUIRED)
**After merging, you MUST review for follow-up issues.** This is a critical step that ensures technical debt and improvements are tracked.

**Check these sources for follow-up items:**
1. **PR review comments** - Any suggestions marked "consider for future" or "nice to have"
2. **Code review feedback** - Items you acknowledged but didn't implement in this PR
3. **TODOs you added** - Any TODO/FIXME comments you wrote during implementation
4. **Incomplete integrations** - Features that work but aren't fully integrated everywhere
5. **Missing edge cases** - Test coverage gaps or error handling improvements noted
6. **Performance optimizations** - Potential improvements identified but not prioritized
7. **Documentation gaps** - API docs, README updates, or examples that should be added

**For each follow-up item, create an issue with:**
- Clear title describing the work
- Background context (reference this PR)
- Specific problem or improvement
- Proposed solution if known

**Use labels defined in CLAUDE.md** when creating issues. If no labels are defined, use sensible defaults like: bug, enhancement, documentation.

**If no follow-up issues are needed, explicitly confirm:** "Reviewed for follow-up issues: none identified."

### Phase 6: Completion Summary (REQUIRED)
Before exiting, write a completion summary to help with future reference:

```bash
# Mark worker as done
work --done
```

Then output a summary including:
- **What was accomplished**: Brief description of the completed work
- **Files changed**: List of key files modified
- **Key decisions made**: Any architectural or implementation choices
- **Follow-up issues created**: Links to any issues created for future work

## Guidelines
- Be thorough but avoid over-engineering
- Write clear commit messages explaining the "why"
- Keep PR description updated with significant changes
- Follow any project-specific guidelines in CLAUDE.md
- If blocked by external factors (permissions, unclear requirements), explain and stop
- **Check for messages**: Periodically check for messages from the parent session:
  ```bash
  work --messages  # Uses WORK_WORKER_ID from environment
  ```
  Messages may contain priority changes, additional context, or instructions.
{worker_guidelines_section}"""


# =============================================================================
# CLI Commands
# =============================================================================

@click.group(invoke_without_command=True)
@click.argument('issues', nargs=-1)
@click.option('--here', is_flag=True, help='Run in current terminal instead of spawning new tab')
@click.option('--status', 'show_status', is_flag=True, help='Show status of all active workers')
@click.option('--events', 'show_events', is_flag=True, help='Show recent worker events')
@click.option('--logs', 'show_logs', is_flag=True, help='Stream worker output')
@click.option('--stop', 'do_stop', is_flag=True, help='Terminate a specific worker')
@click.option('--send', 'do_send', is_flag=True, help='Send a message to a worker')
@click.option('--messages', 'show_messages', is_flag=True, help='View pending messages')
@click.option('--peek', is_flag=True, help='View messages without marking as read')
@click.option('--stage', 'set_stage', help='Set worker stage')
@click.option('--done', 'mark_done', is_flag=True, help='Mark worker as done')
@click.option('--pr', 'set_pr', nargs=2, help='Register PR number and URL')
@click.option('--event', 'log_event', nargs=2, help='Log an event (type, message)')
@click.option('--transition', nargs=3, help='Transition status, phase, stage')
@click.option('--type', 'msg_type', default='info', help='Message type for --send')
@click.option('--init', 'do_init', is_flag=True, help='Create .work.toml config file')
@click.option('--no-ai', 'no_ai', is_flag=True, help='Skip AI generation when using --init')
@click.option('--review', 'do_review', is_flag=True, help='Run self-review of changes')
@click.option('--pre-merge', 'pre_merge', is_flag=True, help='Use stricter pre-merge review (with --review)')
@click.option('--dry-run', 'dry_run', type=click.Choice(['pass', 'fail']), help='Test review without calling Claude (pass/fail)')
@click.option('--reviews', 'show_reviews', is_flag=True, help='Show review history for a commit')
@click.pass_context
def cli(ctx, issues, here, show_status, show_events, show_logs, do_stop, do_send,
        show_messages, peek, set_stage, mark_done, set_pr, log_event, transition, msg_type,
        do_init, no_ai, do_review, pre_merge, dry_run, show_reviews):
    """
    Start Claude Code session(s) for GitHub issue(s) or JIRA tickets.

    \b
    Examples:
      work 97 98 99                    # Spawn 3 issues in new tabs
      work https://github.com/owner/repo/issues/42
      work --here 42 "fix memory leak"  # Run in current terminal
      work "add dark mode support"      # New feature branch
      work AIE-123                       # JIRA issue

    \b
    Config & Review:
      work --init                      # Create .work.toml (auto-generates from CLAUDE.md)
      work --init --no-ai              # Create .work.toml without AI generation
      work --review                    # Run self-review before PR
      work --review --pre-merge        # Run self-review before merge
      work --reviews [ref]             # Show review history (default: HEAD)

    \b
    Worker Management:
      work --status                    # Show all active workers
      work --events [issue]            # Show recent events
      work --logs <issue>              # Stream worker output
      work --stop <issue>              # Signal worker to stop
      work --send <issue> <message>    # Send message to worker
      work --messages [issue]          # View and mark messages as read
      work --messages [issue] --peek   # View without marking as read
      work --stage <stage> [issue]     # Set worker stage
      work --done [issue]              # Mark worker as done
      work --pr <number> <url> [issue] # Register PR for worker
      work --event <type> <msg> [issue] # Log an event
    """

    # Handle init and review commands
    if do_init:
        cmd_init(no_ai=no_ai)
        return

    if do_review:
        cmd_review(pre_merge, dry_run)
        return

    if show_reviews:
        ref = issues[0] if issues else "HEAD"
        cmd_reviews(ref)
        return

    # Handle management commands
    if show_status:
        cmd_status()
        return

    if show_events:
        issue = issues[0] if issues else None
        cmd_events(issue)
        return

    if show_logs:
        if not issues:
            raise click.ClickException("--logs requires an issue argument")
        cmd_logs(issues[0])
        return

    if do_stop:
        if not issues:
            raise click.ClickException("--stop requires an issue argument")
        cmd_stop(issues[0])
        return

    if do_send:
        if len(issues) < 2:
            raise click.ClickException("--send requires <issue> <message>")
        cmd_send(issues[0], " ".join(issues[1:]), msg_type)
        return

    if show_messages:
        issue = issues[0] if issues else None
        cmd_messages(issue, peek)
        return

    if set_stage:
        issue = issues[0] if issues else None
        cmd_stage(set_stage, issue)
        return

    if mark_done:
        issue = issues[0] if issues else None
        cmd_done(issue)
        return

    if set_pr:
        pr_number, pr_url = set_pr
        issue = issues[0] if issues else None
        cmd_pr(int(pr_number), pr_url, issue)
        return

    if log_event:
        event_type, message = log_event
        issue = issues[0] if issues else None
        cmd_event(event_type, message, issue)
        return

    if transition:
        status, phase, stage = transition
        # Check for optional event logging args
        event_type = issues[0] if len(issues) > 0 else None
        message = issues[1] if len(issues) > 1 else None
        issue = issues[2] if len(issues) > 2 else None
        cmd_transition(status, phase, stage, event_type, message, issue)
        return

    # Default: spawn issues
    if not issues:
        click.echo(ctx.get_help())
        return

    if here:
        # Run in current terminal
        description = issues[1] if len(issues) > 1 else None
        run_here(issues[0], description)
    else:
        # Spawn in new tabs
        for i, issue in enumerate(issues):
            if i > 0:
                time.sleep(config.spawn_delay)
            spawn_in_new_tab(issue)
            click.echo(f"Spawned worker for: {issue}")


# =============================================================================
# Init and Review Commands
# =============================================================================

INIT_TEMPLATE = '''\
# .work.toml - Work agent configuration
# See: https://github.com/jimhester/dotfiles/blob/main/genai/work

# Additional instructions appended to the worker prompt.
# Customize for your project's specific conventions.
worker_guidelines = """
## Project-Specific Guidelines

# Examples (uncomment and modify as needed):
# - Run `make lint` before committing
# - Use conventional commit messages (feat:, fix:, docs:, etc.)
# - Update CHANGELOG.md for user-facing changes
"""

# Custom review guidelines for self-review.
# If empty, uses sensible defaults.
review_guidelines = """
## Code Review Guidelines

Focus on bugs actually introduced by these changes:

# Add project-specific checks here, for example:
# - Check for integer overflow in size calculations
# - Verify thread safety of shared data structures
# - Ensure proper error handling for I/O operations

### Ignore
- Style/formatting (handled by formatters)
- Pre-existing issues not introduced by this commit
- Minor nitpicks
"""

# Review strictness: "strict", "normal", or "lenient"
# - strict: Flag anything that could potentially be an issue
# - normal: Balanced (default)
# - lenient: Only flag clear, obvious bugs
review_strictness = "normal"

# Whether to require review before merge (in addition to before PR)
require_pre_merge_review = true
'''


def ensure_hooks_installed() -> None:
    """Check if work hooks are installed and install them if missing."""
    hooks_dir = Path.home() / ".claude" / "hooks"
    settings_file = Path.home() / ".claude" / "settings.json"

    # Check if both hooks exist
    stage_detector = hooks_dir / "work-stage-detector.sh"
    review_guard = hooks_dir / "work-review-guard.sh"

    hooks_missing = not stage_detector.exists() or not review_guard.exists()

    # Check if settings.json has the hooks configured
    settings_missing = False
    if settings_file.exists():
        try:
            settings = json.loads(settings_file.read_text())
            has_pre = any(
                "work-review-guard" in h.get("hooks", [{}])[0].get("command", "")
                for h in settings.get("hooks", {}).get("PreToolUse", [])
            )
            has_post = any(
                "work-stage-detector" in h.get("hooks", [{}])[0].get("command", "")
                for h in settings.get("hooks", {}).get("PostToolUse", [])
            )
            settings_missing = not has_pre or not has_post
        except (json.JSONDecodeError, KeyError):
            settings_missing = True
    else:
        settings_missing = True

    if hooks_missing or settings_missing:
        click.echo("Work hooks not fully installed. Installing...")

        # Find install-hooks.sh relative to this script
        script_dir = Path(__file__).resolve().parent
        install_script = script_dir / "hooks" / "install-hooks.sh"

        if not install_script.exists():
            click.echo(f"Warning: Could not find {install_script}", err=True)
            click.echo("Please run: ~/dotfiles/genai/hooks/install-hooks.sh", err=True)
            return

        result = subprocess.run([str(install_script)], capture_output=False)
        if result.returncode != 0:
            click.echo("Warning: Hook installation may have failed", err=True)
        else:
            click.echo("")


def generate_guidelines_from_claude_md(claude_md_content: str) -> Optional[dict]:
    """Generate project-specific guidelines from CLAUDE.md using Claude."""
    prompt = f"""Analyze this CLAUDE.md file and generate project-specific guidelines for a work agent.

Output a valid TOML configuration with two multi-line string fields. Use triple quotes for multi-line strings.
Do NOT include any markdown code fences or explanation - output ONLY the raw TOML content.

## Required Fields

1. `worker_guidelines` - Instructions for an AI agent working on issues in this repo. Include:
   - GitHub CLI to use (gh vs ghe for enterprise)
   - Development commands (install, test, lint, build, type check)
   - Validation order before committing
   - Project-specific conventions or patterns
   - Required documentation standards
   - Issue labels for follow-up work

2. `review_guidelines` - Checklist for self-reviewing code changes. Include:
   - Project-specific code review checks
   - Common pitfalls to watch for
   - What to ignore (formatting, pre-existing issues)

## CLAUDE.md Content

{claude_md_content}

## Output Format

Output ONLY valid TOML like this (no markdown fences, no explanation):

worker_guidelines = \"\"\"
## Project-Specific Guidelines
...content...
\"\"\"

review_guidelines = \"\"\"
## Code Review Guidelines
...content...
\"\"\""""

    try:
        result = subprocess.run(
            ["claude", "--print", "-p", prompt],
            capture_output=True, text=True,
            stdin=subprocess.DEVNULL,
            timeout=120
        )
        if result.returncode != 0:
            return None

        output = result.stdout.strip()

        # Strip markdown code fences if present
        if output.startswith("```"):
            lines = output.split("\n")
            # Remove first line (```toml or ```)
            lines = lines[1:]
            # Remove last line if it's ```
            if lines and lines[-1].strip() == "```":
                lines = lines[:-1]
            output = "\n".join(lines)

        # Parse TOML output
        import tomli
        return tomli.loads(output)
    except (subprocess.TimeoutExpired, subprocess.CalledProcessError, Exception) as e:
        click.echo(f"Warning: Failed to generate guidelines: {e}", err=True)
        return None


def cmd_init(no_ai: bool = False) -> None:
    """Create .work.toml config file and ensure hooks are installed."""
    # First ensure global hooks are installed
    ensure_hooks_installed()

    repo_root = get_repo_root()
    if not repo_root:
        raise click.ClickException("Not in a git repository")

    config_path = repo_root / ".work.toml"

    if config_path.exists():
        if not click.confirm(f"{config_path} already exists. Overwrite?"):
            click.echo("Aborted.")
            return

    # Check for CLAUDE.md and generate guidelines if available
    claude_md_path = repo_root / "CLAUDE.md"
    generated = None

    if not no_ai and claude_md_path.exists():
        click.echo("Found CLAUDE.md - generating project-specific guidelines...")
        claude_md_content = claude_md_path.read_text()
        # Truncate if very large
        if len(claude_md_content) > 15000:
            claude_md_content = claude_md_content[:15000] + "\n...(truncated)"
        generated = generate_guidelines_from_claude_md(claude_md_content)

    if generated:
        # Build config with generated guidelines
        worker_guidelines = generated.get("worker_guidelines", "").strip()
        review_guidelines = generated.get("review_guidelines", "").strip()

        config_content = f'''# .work.toml - Work agent configuration
# See: https://github.com/jimhester/dotfiles/blob/main/genai/work
# Generated from CLAUDE.md

# Additional instructions appended to the worker prompt.
worker_guidelines = """
{worker_guidelines}
"""

# Custom review guidelines for self-review.
review_guidelines = """
{review_guidelines}
"""

# Review strictness: "strict", "normal", or "lenient"
# - strict: Flag anything that could potentially be an issue
# - normal: Balanced (default)
# - lenient: Only flag clear, obvious bugs
review_strictness = "normal"

# Whether to require review before merge (in addition to before PR)
require_pre_merge_review = true
'''
        config_path.write_text(config_content)
        click.echo(f"Created {config_path} with project-specific guidelines from CLAUDE.md")
    else:
        if not no_ai and claude_md_path.exists():
            click.echo("Could not generate guidelines, using template instead.")
        config_path.write_text(INIT_TEMPLATE)
        click.echo(f"Created {config_path}")
        click.echo("Customize worker_guidelines and review_guidelines for your project.")


def cmd_review(pre_merge: bool = False, dry_run: Optional[str] = None) -> None:
    """Run self-review of changes."""
    # Load project config
    work_config = load_work_config()

    # Check if pre-merge review is required
    if pre_merge and not work_config.require_pre_merge_review:
        click.echo("Pre-merge review not required (disabled in .work.toml)")
        sys.exit(0)

    # Get diff
    diff_cmd = ["git", "diff", "origin/main...HEAD"]
    result = subprocess.run(diff_cmd, capture_output=True, text=True)
    if result.returncode != 0 or not result.stdout.strip():
        click.echo("No changes to review.")
        sys.exit(0)

    diff = result.stdout

    # Load CLAUDE.md for project context
    claude_md = ""
    repo_root = get_repo_root()
    if repo_root:
        claude_md_path = repo_root / "CLAUDE.md"
        if claude_md_path.exists():
            claude_md = claude_md_path.read_text()[:4000]  # Truncate if huge

    # Use custom or default review guidelines
    review_guidelines = work_config.review_guidelines.strip() or DEFAULT_REVIEW_GUIDELINES

    # Adjust for strictness
    strictness_note = ""
    if work_config.review_strictness == "strict":
        strictness_note = "\n\nBe thorough - flag anything that could potentially cause issues."
    elif work_config.review_strictness == "lenient":
        strictness_note = "\n\nOnly flag clear, obvious bugs. Skip uncertain or minor issues."

    # Build review prompt
    review_type = "pre-merge" if pre_merge else "pre-PR"
    pre_merge_note = "\n## Pre-Merge Check\nBe extra thorough - this is the final check before merge." if pre_merge else ""

    prompt = f"""You are reviewing code changes before {"merging" if pre_merge else "opening a PR"}.

## Project Context
{claude_md if claude_md else "(No CLAUDE.md found)"}

## Review Guidelines
{review_guidelines}
{strictness_note}
{pre_merge_note}

## Output Format
If issues found, list each as:
- [HIGH/MEDIUM/LOW] file:line - description

If no issues: Output exactly "APPROVED" on its own line.

## Diff to Review
```diff
{diff}
```
"""

    # Run claude --print for synchronous review (or use mock for dry-run)
    click.echo(f"Running {review_type} review...")

    if dry_run:
        click.echo(f"[DRY-RUN MODE: simulating '{dry_run}']")
        if dry_run == "pass":
            output = "No issues found in the code changes.\n\nAPPROVED"
        else:
            output = "- [HIGH] example.py:42 - Potential null pointer dereference\n- [MEDIUM] utils.py:10 - Missing error handling"
    else:
        result = subprocess.run(
            ["claude", "--print", "-p", prompt],
            capture_output=True, text=True,
            stdin=subprocess.DEVNULL  # Prevent hanging in background tasks
        )
        output = result.stdout

    click.echo(output)

    # Determine if review passed (case-insensitive check)
    passed = "APPROVED" in output.upper()

    # Store review as git note for debugging/history
    head_sha = subprocess.run(
        ["git", "rev-parse", "HEAD"],
        capture_output=True, text=True
    ).stdout.strip()

    if head_sha:
        timestamp = datetime.now().isoformat()
        status = "APPROVED" if passed else "ISSUES_FOUND"
        note_content = f"""[{review_type} review] {timestamp}
Status: {status}
Commit: {head_sha[:8]}

{output}
"""
        # Use refs/notes/reviews namespace to avoid conflicts
        subprocess.run(
            ["git", "notes", "--ref=reviews", "add", "-f", "-m", note_content, "HEAD"],
            capture_output=True
        )
        click.echo(f"Review stored as git note (view with: git notes --ref=reviews show HEAD)")

    # Write marker file (in repo root so it persists and hook can find it)
    if repo_root:
        marker_path = repo_root / ".work-review-status"
        marker_path.write_text(output)
        # Also set env var for current session (hook may use this)
        os.environ["WORK_REVIEW_MARKER"] = str(marker_path)

    # Check result
    if passed:
        click.echo("✅ Review passed!")
        sys.exit(0)
    else:
        click.echo("❌ Review found issues. Please address them.")
        sys.exit(1)


def cmd_reviews(ref: str = "HEAD") -> None:
    """Show review history for a commit."""
    # Resolve the ref to a commit
    result = subprocess.run(
        ["git", "rev-parse", ref],
        capture_output=True, text=True
    )
    if result.returncode != 0:
        raise click.ClickException(f"Invalid git ref: {ref}")

    commit = result.stdout.strip()
    short_commit = commit[:8]

    # Get the review note
    result = subprocess.run(
        ["git", "notes", "--ref=reviews", "show", commit],
        capture_output=True, text=True
    )

    if result.returncode != 0:
        click.echo(f"No review found for {ref} ({short_commit})")
        return

    click.echo(f"Review for {ref} ({short_commit}):")
    click.echo("-" * 60)
    click.echo(result.stdout)


def cmd_status():
    """Show status of all active workers."""
    init_db()
    db_cleanup_stale_workers()

    click.echo("Active Workers:")
    click.echo("-" * 85)
    click.echo(f"{'repo_name':<20} | {'issue':<12} | {'status':<10} | {'stage':<17} | mins_idle")
    click.echo("-" * 85)

    with get_db() as conn:
        cursor = conn.execute("""
            SELECT repo_name,
                   COALESCE(jira_key, CAST(issue_number AS TEXT), '-') as issue,
                   status,
                   COALESCE(stage, phase) as stage,
                   CAST((julianday('now') - julianday(updated_at)) * 24 * 60 AS INTEGER) as mins_idle
            FROM workers
            WHERE status NOT IN ('done', 'failed')
            ORDER BY updated_at DESC
        """)
        for row in cursor:
            click.echo(f"{row['repo_name']:<20} | {row['issue']:<12} | {row['status']:<10} | {row['stage']:<17} | {row['mins_idle']}")

        cursor = conn.execute(
            "SELECT COUNT(*) as count FROM workers WHERE status NOT IN ('done', 'failed')"
        )
        count = cursor.fetchone()["count"]

    click.echo("-" * 85)
    click.echo(f"Total active workers: {count}")


def cmd_events(issue: Optional[str] = None):
    """Show recent worker events."""
    init_db()

    with get_db() as conn:
        if issue:
            identifier, repo = parse_issue_arg(issue)
            worker_id = db_get_worker_by_issue(identifier, repo)
            if not worker_id:
                raise click.ClickException(f"No active worker found for: {issue}")

            cursor = conn.execute("""
                SELECT e.created_at, w.repo_name,
                       COALESCE(w.jira_key, CAST(w.issue_number AS TEXT), '-') as issue,
                       e.event_type, e.message
                FROM events e
                JOIN workers w ON e.worker_id = w.id
                WHERE e.worker_id = ?
                ORDER BY e.created_at DESC
                LIMIT 50
            """, (worker_id,))
        else:
            cursor = conn.execute("""
                SELECT e.created_at, w.repo_name,
                       COALESCE(w.jira_key, CAST(w.issue_number AS TEXT), '-') as issue,
                       e.event_type, e.message
                FROM events e
                JOIN workers w ON e.worker_id = w.id
                ORDER BY e.created_at DESC
                LIMIT 50
            """)

        click.echo("Recent Events:")
        click.echo("-" * 100)
        for row in cursor:
            click.echo(f"[{row['created_at']}] {row['repo_name']}#{row['issue']} ({row['event_type']}): {row['message']}")
        click.echo("-" * 100)


def cmd_logs(issue: str):
    """Show logs for a specific worker."""
    init_db()
    identifier, repo = parse_issue_arg(issue)
    worker_id = db_get_worker_by_issue(identifier, repo)

    if not worker_id:
        raise click.ClickException(f"No active worker found for: {issue}")

    with get_db() as conn:
        cursor = conn.execute(
            "SELECT status, phase, pid FROM workers WHERE id=?",
            (worker_id,)
        )
        row = cursor.fetchone()
        if row:
            click.echo(f"Worker Status: {row['status']} | Phase: {row['phase']} | PID: {row['pid']}")
            click.echo("-" * 60)

        cursor = conn.execute("""
            SELECT created_at, event_type, message
            FROM events WHERE worker_id = ?
            ORDER BY created_at DESC
            LIMIT 50
        """, (worker_id,))

        for row in cursor:
            click.echo(f"[{row['created_at']}] ({row['event_type']}): {row['message']}")


def cmd_stop(issue: str):
    """Stop a worker."""
    init_db()
    identifier, repo = parse_issue_arg(issue)
    worker_id = db_get_worker_by_issue(identifier, repo)

    if not worker_id:
        raise click.ClickException(f"No active worker found for: {issue}")

    with get_db() as conn:
        cursor = conn.execute("SELECT pid FROM workers WHERE id=?", (worker_id,))
        row = cursor.fetchone()
        if not row or not row["pid"]:
            raise click.ClickException("Worker has no PID")

        pid = row["pid"]

    try:
        os.kill(pid, signal.SIGTERM)
        click.echo(f"Sent SIGTERM to PID {pid}")
        time.sleep(1)

        if is_worker_alive(pid):
            os.kill(pid, signal.SIGKILL)
            click.echo(f"Sent SIGKILL to PID {pid}")
    except (OSError, ProcessLookupError) as e:
        click.echo(f"Process already terminated: {e}")

    db_mark_failed(worker_id, "Stopped by user")
    click.echo(f"Worker marked as failed")


def cmd_send(issue: str, message: str, msg_type: str = "info"):
    """Send a message to a worker."""
    init_db()
    identifier, repo = parse_issue_arg(issue)
    worker_id = db_get_worker_by_issue(identifier, repo)

    if not worker_id:
        raise click.ClickException(f"No active worker found for: {issue}")

    db_send_message(worker_id, msg_type, message)
    click.echo(f"Message sent to worker for: {issue}")


def cmd_messages(issue: Optional[str] = None, peek: bool = False):
    """View pending messages for a worker."""
    init_db()

    # Try to get worker ID from environment or argument
    worker_id = None
    if issue:
        identifier, repo = parse_issue_arg(issue)
        worker_id = db_get_worker_by_issue(identifier, repo)
    else:
        worker_id = os.environ.get("WORK_WORKER_ID")
        if worker_id:
            worker_id = int(worker_id)

    if not worker_id:
        raise click.ClickException(
            "No worker specified. Provide an issue argument or set WORK_WORKER_ID."
        )

    count = db_get_message_count(worker_id)
    if count == 0:
        click.echo("No unread messages.")
        return

    click.echo(f"Unread Messages ({count}):")
    click.echo("-" * 79)

    messages = db_get_messages(worker_id, mark_read=not peek)
    for msg in messages:
        click.echo(f"[{msg['created_at']}] ({msg['message_type']}) {msg['payload']}")

    click.echo("-" * 79)
    if not peek:
        click.echo("All messages marked as read.")
    else:
        click.echo("(Peek mode - messages NOT marked as read)")


def cmd_stage(stage: str, issue: Optional[str] = None):
    """Set worker stage."""
    init_db()

    worker_id = None
    if issue:
        identifier, repo = parse_issue_arg(issue)
        worker_id = db_get_worker_by_issue(identifier, repo)
    else:
        worker_id = os.environ.get("WORK_WORKER_ID")
        if worker_id:
            worker_id = int(worker_id)

    if not worker_id:
        raise click.ClickException(
            "No worker specified. Provide an issue argument or set WORK_WORKER_ID."
        )

    db_update_stage(worker_id, stage)
    click.echo(f"Stage updated to: {stage}")


def cmd_done(issue: Optional[str] = None):
    """Mark worker as done."""
    init_db()

    worker_id = None
    if issue:
        identifier, repo = parse_issue_arg(issue)
        worker_id = db_get_worker_by_issue(identifier, repo)
    else:
        worker_id = os.environ.get("WORK_WORKER_ID")
        if worker_id:
            worker_id = int(worker_id)

    if not worker_id:
        raise click.ClickException(
            "No worker specified. Provide an issue argument or set WORK_WORKER_ID."
        )

    db_update_status(worker_id, "done")
    db_update_stage(worker_id, "done")
    db_log_event(worker_id, "completed", "Worker marked as done")
    click.echo("Worker marked as done.")


def cmd_pr(pr_number: int, pr_url: str, issue: Optional[str] = None):
    """Register PR for worker."""
    init_db()

    worker_id = None
    if issue:
        identifier, repo = parse_issue_arg(issue)
        worker_id = db_get_worker_by_issue(identifier, repo)
    else:
        worker_id = os.environ.get("WORK_WORKER_ID")
        if worker_id:
            worker_id = int(worker_id)

    if not worker_id:
        raise click.ClickException(
            "No worker specified. Provide an issue argument or set WORK_WORKER_ID."
        )

    db_update_pr(worker_id, pr_number, pr_url)
    db_update_stage(worker_id, "ci_waiting")
    db_log_event(worker_id, "pr_created", f"PR #{pr_number}: {pr_url}")
    click.echo(f"PR registered: #{pr_number}")


def cmd_event(event_type: str, message: str, issue: Optional[str] = None):
    """Log a custom event."""
    init_db()

    worker_id = None
    if issue:
        identifier, repo = parse_issue_arg(issue)
        worker_id = db_get_worker_by_issue(identifier, repo)
    else:
        worker_id = os.environ.get("WORK_WORKER_ID")
        if worker_id:
            worker_id = int(worker_id)

    if not worker_id:
        raise click.ClickException(
            "No worker specified. Provide an issue argument or set WORK_WORKER_ID."
        )

    db_log_event(worker_id, event_type, message)
    click.echo(f"Event logged: {event_type}")


def cmd_transition(
    status: str,
    phase: str,
    stage: str,
    event_type: Optional[str] = None,
    message: Optional[str] = None,
    issue: Optional[str] = None
):
    """Atomic state transition."""
    init_db()

    worker_id = None
    if issue:
        identifier, repo = parse_issue_arg(issue)
        worker_id = db_get_worker_by_issue(identifier, repo)
    else:
        worker_id = os.environ.get("WORK_WORKER_ID")
        if worker_id:
            worker_id = int(worker_id)

    if not worker_id:
        raise click.ClickException(
            "No worker specified. Provide an issue argument or set WORK_WORKER_ID."
        )

    db_update_status(worker_id, status, phase)
    db_update_stage(worker_id, stage)

    if event_type and message:
        db_log_event(worker_id, event_type, message)

    click.echo(f"Transitioned to: status={status}, phase={phase}, stage={stage}")


def run_here(input_str: str, description: Optional[str] = None):
    """Run worker in current terminal."""
    repo_root = get_repo_root()
    if not repo_root:
        raise click.ClickException("Not in a git repository")

    repo_name = repo_root.name
    gh_cli = detect_gh_cli()

    # Parse input
    issue_number: Optional[int] = None
    issue_owner: Optional[str] = None
    issue_repo: Optional[str] = None
    issue_type: Optional[str] = None
    jira_key: Optional[str] = None
    branch_name: Optional[str] = None
    issue_source = "github"

    # Try JIRA first (if acli available), then GitHub
    jira_key = parse_jira_key(input_str)
    if jira_key and subprocess.run(["which", "acli"], capture_output=True).returncode == 0:
        issue_source = "jira"
        click.echo(f"Found JIRA issue: {jira_key}")

        # Check for existing branch
        branch_name = find_existing_branch(jira_key)
        if branch_name:
            click.echo(f"Found existing branch: {branch_name}")
        else:
            # Fetch summary if no description provided
            if not description:
                click.echo("Fetching issue summary from JIRA...")
                description = fetch_jira_summary(jira_key)

            if description:
                branch_name = f"{jira_key}-{slugify(description)}"
            else:
                branch_name = jira_key
            click.echo(f"Will create new branch: {branch_name}")
    else:
        jira_key = None  # Reset if acli not available

        # Try GitHub URL/number parsing
        parsed = parse_github_url(input_str)
        if parsed:
            issue_owner = parsed.owner
            issue_repo = parsed.repo
            issue_type = parsed.issue_type
            issue_number = parsed.number

            # Check for repo mismatch
            if issue_repo and issue_repo != repo_name:
                raise click.ClickException(
                    f"Repository mismatch!\n"
                    f"  URL is for: {issue_repo}\n"
                    f"  Current repo: {repo_name}\n"
                    f"Run this command from the {issue_repo} repository."
                )
        elif input_str.isdigit():
            issue_number = int(input_str)
            issue_type = "issues"
            # Get owner/repo from remote
            try:
                result = subprocess.run(
                    ["git", "remote", "get-url", "origin"],
                    capture_output=True, text=True, check=True
                )
                match = re.search(r'github(?:\.netflix)?\.(?:com|net)[:/]([^/]+)/([^/.\s]+)', result.stdout)
                if match:
                    issue_owner = match.group(1)
                    issue_repo = match.group(2).replace('.git', '')
            except subprocess.CalledProcessError:
                pass
        else:
            # Treat as feature description
            description = input_str

        # Find or create branch for GitHub issue
        if issue_number:
            click.echo(f"Found GitHub {issue_type}: #{issue_number}")

            if issue_type == "pull":
                # For PRs, fetch the branch name
                branch_name = fetch_pr_branch(issue_number, gh_cli)
                if branch_name:
                    click.echo(f"PR branch: {branch_name}")

            if not branch_name:
                # Check for existing branch
                branch_name = find_existing_branch(f"issue-{issue_number}-")
                if branch_name:
                    click.echo(f"Found existing branch: {branch_name}")
                else:
                    # Fetch title if no description
                    if not description:
                        click.echo("Fetching issue title...")
                        description = fetch_issue_title(issue_number, gh_cli)

                    if description:
                        branch_name = f"issue-{issue_number}-{slugify(description)}"
                    else:
                        branch_name = f"issue-{issue_number}"
                    click.echo(f"Will create new branch: {branch_name}")
        elif description:
            # Feature branch
            branch_name = f"feature-{slugify(description)}"
            click.echo(f"Will create feature branch: {branch_name}")

    if not branch_name:
        raise click.ClickException("Could not determine branch name")

    # Find or create worktree
    worktree_path = find_existing_worktree(branch_name)
    if worktree_path:
        click.echo(f"Using existing worktree: {worktree_path}")
    else:
        worktree_path = config.worktree_base / repo_name / branch_name
        worktree_path.parent.mkdir(parents=True, exist_ok=True)

        # Check if branch exists locally
        result = subprocess.run(
            ["git", "rev-parse", "--verify", branch_name],
            capture_output=True
        )
        branch_exists_locally = result.returncode == 0

        # Fetch latest remote refs to check for remote branches
        subprocess.run(["git", "fetch", "--quiet"], capture_output=True)

        # Check if branch exists on remote
        result = subprocess.run(
            ["git", "rev-parse", "--verify", f"origin/{branch_name}"],
            capture_output=True
        )
        branch_exists_on_remote = result.returncode == 0

        if branch_exists_locally:
            # Branch exists locally
            click.echo(f"Creating worktree for existing local branch: {branch_name}")
            subprocess.run(
                ["git", "worktree", "add", str(worktree_path), branch_name],
                check=True
            )
        elif branch_exists_on_remote:
            # Branch exists on remote but not locally - create tracking branch
            click.echo(f"Creating worktree for remote branch: origin/{branch_name}")
            subprocess.run(
                ["git", "worktree", "add", "--track", "-b", branch_name, str(worktree_path), f"origin/{branch_name}"],
                check=True
            )
        else:
            # Create new branch from main
            click.echo(f"Creating worktree with new branch: {branch_name}")
            subprocess.run(
                ["git", "worktree", "add", "-b", branch_name, str(worktree_path), config.main_branch],
                check=True
            )

    # Build task reference
    task_ref = ""
    if issue_source == "jira" and jira_key:
        task_ref = f"JIRA issue {jira_key} (https://netflix.atlassian.net/browse/{jira_key})"
    elif issue_number and issue_owner and issue_repo:
        if issue_type == "pull":
            task_ref = f"GitHub PR https://github.com/{issue_owner}/{issue_repo}/pull/{issue_number}"
        else:
            task_ref = f"GitHub issue https://github.com/{issue_owner}/{issue_repo}/issues/{issue_number}"
    elif issue_number:
        task_ref = f"Issue #{issue_number}"
    else:
        task_ref = description or branch_name

    # Generate prompt
    prompt = generate_prompt(task_ref, gh_cli, jira_key)

    # Check if already in Claude Code
    if os.environ.get("CLAUDE_CODE"):
        click.echo("Already in Claude Code session. Here's the task prompt:")
        click.echo("-" * 60)
        click.echo(prompt)
        return

    # Set terminal title
    title = jira_key or (f"Issue #{issue_number}" if issue_number else (description or branch_name)[:30])
    sys.stdout.write(f"\033]0;{title}\007")
    sys.stdout.flush()

    # Register worker
    worker_id = db_register_worker(
        str(repo_root),
        repo_name,
        issue_number,
        branch_name,
        str(worktree_path),
        os.getpid(),
        jira_key,
        issue_source
    )
    db_log_event(worker_id, "started", f"Worker started for {task_ref}")
    db_update_status(worker_id, "running", "implementation")

    # Set environment for hooks
    os.environ["WORK_WORKER_ID"] = str(worker_id)
    os.environ["WORK_DB_PATH"] = str(config.db_path)

    click.echo("Starting Claude Code session...")
    click.echo(f"  Worker ID: {worker_id}")

    # Change to worktree and exec claude
    os.chdir(worktree_path)
    os.execvp("claude", ["claude", "--dangerously-skip-permissions", prompt])


if __name__ == "__main__":
    cli()
